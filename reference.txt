// 4-73 CLR

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃  Integer Data Formats                                                                   ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│ Operand Data Format       │ Size        │      Notes                                    │
├───────────────────────────┼─────────────┼───────────────────────────────────────────────┤
│ Bit                       │ 1 Bit       │                                               │
├───────────────────────────┼─────────────┼───────────────────────────────────────────────┤
│ Bit Field                 │ 1 - 32 Bits │ Field of Consecutive Bit                      │
├───────────────────────────┼─────────────┼───────────────────────────────────────────────┤
│ Binary-Coded Decimal (BCD)│ 8 Bits      │ Packed: 2 Digits/Byte; Unpacked: 1 Digit/Byte │
├───────────────────────────┼─────────────┼───────────────────────────────────────────────┤
│ Byte Integer              │ 8 Bits      │                                               │
├───────────────────────────┼─────────────┼───────────────────────────────────────────────┤
│ Word Integer              │ 16 Bits     │                                               │
├───────────────────────────┼─────────────┼───────────────────────────────────────────────┤
│ Long-Word Integer         │ 32 Bits     │                                               │
├───────────────────────────┼─────────────┼───────────────────────────────────────────────┤
│ Quad-Word Integer         │ 64 Bits     │ Any Two Data Registers                        │
├───────────────────────────┼─────────────┼───────────────────────────────────────────────┤
│ 16-Byte                   │ 128 Bits    │ Memory Only, Aligned to 16-Byte Boundary      │
├───────────────────────────┼─────────────┼───────────────────────────────────────────────┤
│                           │             │                                               │
└───────────────────────────┴─────────────┴───────────────────────────────────────────────┘

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                               Single and Double Operand Operations                                              ┃
┣━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│      +          │ Arithmetic addition or postincrement indicator.                                               │
├─────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│      -          │ Arithmetic subtraction or predecrement indicator.                                             │
├─────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│      x          │ Arithmetic multiplication.                                                                    │
├─────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│      ÷          │ Arithmetic division or conjunction symbol.                                                    │
├─────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│      ~          │ Invert; operand is logically complemented.                                                    │
├─────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│      ۸          │ Logical AND                                                                                   │
├─────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│      ۷          │ Logical OR                                                                                    │
├─────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│      ⊕          │ Logical exclusive OR                                                                          │
├─────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│      →          │ Source operand is moved to destination operand.                                               │
├─────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│     ← →         │ Two operands are exchanged.                                                                   │
├─────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│    <op>         │ Any double-operand operation.                                                                 │
├─────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│ <operand>tested │ Operand is compared to zero and the condition codes are set appropriately.                    │
├─────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────┤
│ sign-extended   │ All bits of the upper portion are made equal to the high-order bit of the lower portion.      │
├─────────────────┴───────────────────────────────────────────────────────────────────────────────────────────────┤
│                                    Other Operations                                                             │
├───────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────┤
│      TRAP         │ Equivalent to Format ÷ Offset Word → (SSP);                                                 │
│                   │ SSP - 2 → SSP;                                                                              │
│                   │ PC → (SSP);                                                                                 │
│                   │ SSP - 4 → SSP;                                                                              │
│                   │ SR → (SSP);                                                                                 │
│                   │ SSP - 2 → SSP;                                                                              │
│                   │ (Vector) → PC                                                                               │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│    STOP           │ Enter the stopped state, waiting for interrupts.                                            │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│ <operand>10       │ The operand is BCD; operations are performed in decimal.                                    │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│ if <condition>    │ Test the condition. If true, the operations after "then" are performed. If The condition is │
│ then <operations> │ false and the optional "else" clause is present, the operations after "else" are performed. │
│ else <operations> │ If the condition is false and else is omitted, the instruction performs no operation. Refer │
│                   │ to the Bcc instruction description as an example.                                           │
├───────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────┤
│                                 Register Specifications                                                         │
├──────────────┬──────────────────────────────────────────────────────────────────────────────────────────────────┤
│     An       │ Any Address Register n (example: A3 is address register 3)                                       │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│   Ax, Ay     │ Source and destination address registers, respectively.                                          │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│     Dc       │ Data register D7-D0, used during compare.                                                        │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│   Dh, Dl     │ Data register's high- or low-order 32 bits of product.                                           │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│     Dn       │ Any Data Register n (example: D5 is data register 5)                                             │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│   Dr, Dq     │ Data register's remainder or quotient of divide.                                                 │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│     Du       │ Data register D7-D0, used during update.                                                         │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│   Dx, Dy     │ Source and destination data registers, respectively.                                             │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│     MRn      │ Any Memory Register n.                                                                           │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│     Rn       │ Any Address or Data Register                                                                     │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│   Rx, Ry     │ Any source and destination registers, respectively.                                              │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│     Xn       │ Index Register                                                                                   │
├──────────────┴──────────────────────────────────────────────────────────────────────────────────────────────────┤
│             Data Format And Type                                                                                │
├──────────────┬──────────────────────────────────────────────────────────────────────────────────────────────────┤
│   + inf      │ Positive Infinity                                                                                │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│   <fmt>      │ Operand Data Format: Byte (B), Word (W), Long (L), Single (S), Double (D), Extended (X), or      │
│              │ Packed (P).                                                                                      │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│  B, W, L     │ Specifies a signed integer data type (twos complement) of byte, word, or long word.              │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│     D        │ Double-precision real data format (64 bits)                                                      │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│     k        │ A twos complement signed integer (-64 to +17) specifying a number's format to be stored in the   │
│              │ packed decimal format.                                                                           │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│     P        │ Packed BCD real data format (96 bits, 12 bytes).                                                 │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│     S        │ Single-precision real data format (32 bits).                                                     │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│     X        │ Extended-precision real data format (96 bits, 16 bits unused.).                                  │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│   -inf       │ Negative Infinity                                                                                │
├──────────────┴──────────────────────────────────────────────────────────────────────────────────────────────────┤
│             Subfields and Qualifiers                                                                            │
├───────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────┤
│ #<xxx> or #<data> │ Immediate data following the instruction word(s).                                           │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│        ( )        │ Identifies an indirect address in a register                                                │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│        [ ]        │ Identifies an indirect address in memory.                                                   │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│        bd         │ Base Displacement                                                                           │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│       ccc         │ Index into the MC68881/MC68882 Constant ROM                                                 │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│        dn         │ Displacement Value, n Bits Wide (example: d16 is a 16-bit displacement).                    │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│       LSB         │ Least Significant Bit                                                                       │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│       LSW         │ Least Significant Word                                                                      │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│       MSB         │ Most Significant Bit                                                                        │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│       MSW         │ Most Significant Word                                                                       │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│       od          │ Outer Displacement                                                                          │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│    SCALE          │ A scale factor (1, 2, 4, or 8 for no-word, word, long-word, or quad-word scaling,           │
│                   │ respectively).                                                                              │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│    SIZE           │ The index register's size (W for word, L for long word).                                    │
├───────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────┤
│  {offset:width}   │ Bit field selection.                                                                        │
├───────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────┤
│                Register Nmes                                                                                    │
├──────────────┬──────────────────────────────────────────────────────────────────────────────────────────────────┤
│    CCR       │ Condition Code Register (lower byte of status register)                                          │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│    DFC       │ Destination Function Code Register                                                               │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│    FPcr      │ Any Floating-Point System Control Register (FPCR, FPSR, or FPIAR)                                │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│    FPm, FPn  │ Any Floating-Point Data Register specified as the source or destination, respectively.           │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│ IC, DC, IC/DC│ Instruction, Data, or Both Caches                                                                │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│   MMUSR      │ MMU Status Register                                                                              │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│    PC        │ Program Counter                                                                                  │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│    Rc        │ Any Non Floating-Point Control Register                                                          │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│    SFC       │ Source Function Code Register                                                                    │
├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────┤
│    SR        │ Status Register                                                                                  │
├──────────────┴──────────────────────────────────────────────────────────────────────────────────────────────────┤
│                Register Codes                                                                                   │
├──────────────┬───────────────────────────────────────┬──────────────────────────────────────────────────────────┘
│      *       │ General Case                          │
├──────────────┼───────────────────────────────────────┤
│      C       │ Carry Bit in CCR                      │
├──────────────┼───────────────────────────────────────┤
│     cc       │ Condition Codes from CCR              │
├──────────────┼───────────────────────────────────────┤
│     FC       │ Function code                         │
├──────────────┼───────────────────────────────────────┤
│      N       │ Negative Bit in CCR                   │
├──────────────┼───────────────────────────────────────┤
│      U       │ Undefined, Reserved for Motoroal Use. │
├──────────────┼───────────────────────────────────────┤
│      V       │ Overflow Bit in CCR                   │
├──────────────┼───────────────────────────────────────┤
│      X       │ Extend Bit in CCR                     │
├──────────────┼───────────────────────────────────────┤
│      Z       │ Zero Bit in CCR                       │
├──────────────┼───────────────────────────────────────┤
│      -       │ Not Affected or Applicable            │
├──────────────┴───────────────────────────────────────┴───────┐
│                Stack Pointers                                │
├──────────────┬───────────────────────────────────────────────┤
│     ISP      │ Supervisor/Interrupt Stack Pointer            │
├──────────────┼───────────────────────────────────────────────┤
│     MSP      │ Supervisor/Master Stack Pointer               │
├──────────────┼───────────────────────────────────────────────┤
│     SP       │ Active Stack Pointer                          │
├──────────────┼───────────────────────────────────────────────┤
│     SSP      │ Supervisor (Master or Interrupt Stack Pointer)│
├──────────────┼───────────────────────────────────────────────┤
│     USP      │ User Stack Pointer                            │
├──────────────┴───────────────────────────────────────────────┤
│                Miscellaneous                                 │
├──────────────┬───────────────────────────────────────────────┤
│    <ea>      │ Effective Address                             │
├──────────────┼───────────────────────────────────────────────┤
│   <label>    │ Assemble Program Label                        │
├──────────────┼───────────────────────────────────────────────┤
│   <list>     │ List of registers, for example D3-D0          │
├──────────────┼───────────────────────────────────────────────┤
│     LB       │ Lower Bound                                   │
├──────────────┼───────────────────────────────────────────────┤
│     m        │ Bit m of an Operand                           │
├──────────────┼───────────────────────────────────────────────┤
│     m-n      │ Bits m through n of Operand                   │
├──────────────┼───────────────────────────────────────────────┤
│     UB       │ Upper Bound                                   │
├──────────────┼───────────────────────────────────────────────┤
│              │                                               │
└──────────────┴───────────────────────────────────────────────┘

# Data Movement Instructions
The MOVE and FMOVE instructions with their associated addressing modes are the basic means of transferring and storing addresses and data. MOVE instructions transfer byte, word, and long-word operands from memory to memory, memory to register, register to memory, and register to register. MOVE instructions transfer word and long-word operands and ensure that only valid address manipulations are executed. In addition to the general MOVE instructions, there are several special data movement instructions: MOVE16, MOVEM, MOVEP, MOVEQ, EXG, LEA, PEA, LINK, and UNLK. The MOVE16 instruction is an MC68040 extension to the M68000 instruction set.
The FMOVE instructions move operands into, out of, and between floating-point data registers. FMOVE also moves operands to and from the floating-point control register (FPCR), floating-point status register (FPSR), and floating-point instruction address register (FPIAR). For operands moved into a floating-point data register, FSMOVE and FDMOVE explicitly select single- and double-precision rounding of the result, respectively. FMOVEM moves any combination of either floating-point data registers or floating-point control registers. Table 3-2 lists the general format of these integer and floating-point data movement instructions.

## Data Movement Operation Format
┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Instruction     ┃ Operand Syntax      ┃ Operand Size        ┃                    Operation                                                             ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│ EXG             │ Rn, Rn              │       32            │  Rn ← → Rn                                                                               │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FMOVE           │ FPm, FPn            │       X             │ Source → Destination                                                                     │
│                 │ <ea>, FPn           │ B, W, L, S, D, X, P │ Floating precision move.                                                                 │
│                 │ FPm, <ea>           │ B, W, L, S, D, X, P │                                                                                          │
│                 │ <ea>, FPcr          │       32            │                                                                                          │
│                 │ FPcr, <ea>          │       32            │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FSMOVE,         │ FPm, FPn            │       X             │ Source → Destination; round destination to single or                                     │
│ FDMOVE          │ <ea>, FPn           │ B, W, L, S, D, X    │ double precision.                                                                        │
│                 │                     │                     │ Floating precision move.                                                                 │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FMOVEM          │ <ea>, <list>        │ 32, X               │ Listed Registers → Destination                                                           │
│                 │ <ea>, Dn            │   X                 │                                                                                          │
│                 │ <list>, <ea>        │ 32, X               │ Source → Listed Registers                                                                │
│                 │ Dn, <ea>            │   X                 │                                                                                          │
│                 │                     │                     │ Move multiple                                                                            │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ LEA             │ <ea>, An            │ 16, 32              │ <ea> → An Load Effective Address                                                         │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ In short, LEA loads a pointer to the item you're                                         │
│                 │                     │                     │ addressing whereas MOV loads the actual value at that                                    │
│                 │                     │                     │ address.                                                                                 │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ lea eax, [ebp - 4] The value of ebp is subtracted by                                     │
│                 │                     │                     │ 4 and the resulting value is stored in eax. This                                         │
│                 │                     │                     │ instruction would just calculate the address and                                         │
│                 │                     │                     │ store the calculated value in the destination                                            │
│                 │                     │                     │ register. See this post for further details.                                             │
│                 │                     │                     │ https://stackoverflow.com/a/25824111/808603                                              │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ LINK            │ An, #<d>            │  16, 32             │ SP → - 4 → SP; An → (SP); SP An, SP + D → SP                                             │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Allocates or creates a frame in the stack for local                                      │
│                 │                     │                     │ use by the subroutine of size d bytes.                                                   │
│                 │                     │                     │ • An is an address register serving as the frame                                         │
│                 │                     │                     │   pointer (FP); A6 is used.                                                              │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ After creating the frame:                                                                │
│                 │                     │                     │ – Passed parameters are accessed with a positive                                         │
│                 │                     │                     │   displacement with respect to FP, A6                                                    │
│                 │                     │                     │   i.e MOVE.W 8(A6),D0                                                                    │
│                 │                     │                     │ – Local temporary storage variables are accessed                                         │
│                 │                     │                     │   with negative displacement with respect to A6                                          │
│                 │                     │                     │   i.e. MOVE.L D2,-10(A6)                                                                 │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ The LINK instruction pushes an address onto the stack, saves the stack address at which  │
│                 │                     │                     │ the address is stored, and reserves an area of the stack. Using this instruction in a    │
│                 │                     │                     │ series of subroutine calls results in a linked list of stack frames.                     │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MOVE            │ <ea>, <ea>          │ 8, 16, 32           │ Source → Destination                                                                     │
│ MOVE16          │ <ea>, <ea>          │ 16 bytes            │ Aligned 16-Byte Block → Destination                                                      │
│ MOVEA           │ <ea>, An            │ 16, 32 → 32         │                                                                                          │
│                 │                     │                     │ This instruction moves the byte, word, or long-word operand from the specified general   │
│                 │                     │                     │ register to a location within the address space specified by the destination function    │
│                 │                     │                     │ code (DFC) register. It also moves the byte, word, or long-word operand from a location  │
│                 │                     │                     │ within the address space specificed by the source function code (SFC) register to the    │
│                 │                     │                     │ specified general register.                                                              │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MOVEM           │ list, <ea>          │ 16, 32              │ Listed Registers → Destination                                                           │
│                 │ <ea>, list          │ 16, 32 → 32         │ Source → Listed Registers                                                                │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MOVEP           │ Dn, (d16, An)       │ 16, 32              │ Dn 31 - 24 → (An + dn); Dn 23 - 16 → (An + dn + 2);                                      │
│                 │                     │                     │ Dn 15 - 8 → (An + dn + 4); Dn 7 - 0 → (An + dn + 6)                                      │
│                 │ (d16, An), Dn       │                     │ (An + dn) → Dn 31 - 24; (An + dn + 2) → Dn 23 - 16                                       │
│                 │                     │                     │ (An + dn + 4) → Dn 15 - 8; (An + dn + 6) → Dn 7 - 0                                      │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MOVEQ           │ #<data>, Dn         │ 8 → 32              │ Immediate Data → Destination                                                             │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ PEA             │ <ea>                │ 32                  │ SP - 4 → SP; <ea> → (SP)                                                                 │
│                 │                     │                     │ Push Effective Address                                                                   │
│                 │                     │                     │ Its the counter part to LEA                                                              │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ UNLK            │ An                  │ 32                  │ An → SP; (SP) → An; SP + 4 → SP                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ The UNLK instruction removes a stack frame from the end of the list by loading an address│
│                 │                     │                     │ into the stack pointer and pulling the value at that address from the stack. When the    │
│                 │                     │                     │ operand of the instruction is the address of the link address at the bottom of a stack   │
│                 │                     │                     │ frame, the effect is to remove the stack frame from the stack and from the linked list.  │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘
NOTE: A register list includes any combination of the eight floating-point data registers or any combination of three control registers (FPCR, FPSR, and FPIAR). If a register list mask resides in a data register, only floating-point data registers may be specified.

# Integer Arithmetic Instructions
The integer arithmetic operations include four basic operations: ADD, SUB, MUL, and DIV. They also include CMP, CMPM, CMP2, CLR, and NEG. The instruction set includes ADD, CMP, and SUB instructions for both address and data operations with all operand sizes valid for data operations. Address operands consist of 16 or 32 bits. The CLR and NEG instructions apply to all sizes of data operands. Signed and unsigned MUL and DIV instructions include:
    * Word multiply to produce a long-word product.
    * Long-word multiply to produce a long-word or quad-word product.
    * Long word divided by a word divisor (word quotient and word remainder).
    * Long word or quad word divided by a long-word divisor (long-word quotient and long- word remainder).
A set of extended instructions provides multiprecision and mixed-size arithmetic: ADDX, SUBX, EXT, and NEGX. Refer to Table 3-3 for a summary of the integer arithmetic operations. In Table 3-3, X refers to the X-bit in the CCR.

┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Instruction     ┃ Operand Syntax      ┃ Operand Size        ┃                    Operation                                                             ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│ ADD             │ Dn, <ea>            │ 8, 16, 32           │ Source + Destination → Destination                                                       │
│                 │ <ea>, Dn            │ 8, 16, 32           │                                                                                          │
│                 │                     │                     │ Adds the source operand to the destination operand using binary addition and stores the  │
│                 │                     │                     │ result in the destination location. The size of the operation may be specified as byte,  │
│                 │                     │                     │ word, or long. The mode of the instruction indicates which operand is the source and     │
│                 │                     │                     │ which is the destination, as well as the operand size.                                   │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Note                                                                                     │
│                 │                     │                     │ The Dn mode is used when the destination is a data register; the destination <ea> mode   │
│                 │                     │                     │ is invalid for a data register.  ADDA is used when the destination is an address         │
│                 │                     │                     │ register. ADDI and ADDQ are used when the source is immediate data. Most assemblers      │
│                 │                     │                     │ automatically make this distinction.                                                     │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ADDA            │ <ea>, An            │    16, 32           │ Source + Destination → Destination                                                       │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Adds the source operand to the destination address register and stores the result in the │
│                 │                     │                     │ address register. The size of the operation may be specified as word or long. The entire │
│                 │                     │                     │ destination address register is used regardless of the operation size.                   │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ADDI            │ #<data>, <ea>       │  8, 16, 32          │ Immediate Data + Destination → Destination                                               │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Adds the immediate data to the destination operand and stores the result in the          │
│                 │                     │                     │ destination location. The size of the operation may be specified as byte, word, or long. │
│                 │                     │                     │ The size of the immediate data matches the operation size.                               │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ADDQ            │ #<data>, <ea>       │  8, 16, 32          │ Immediate Data + Destination → Destination                                               │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Description: Adds an immediate value of one to eight to the operand at the destination   │
│                 │                     │                     │ location. The size of the operation may be specified as byte, word, or long. Word and    │
│                 │                     │                     │ long operations are also allowed on the address registers. When adding to address        │
│                 │                     │                     │ registers, the condition codes are not altered, and the entire destination address       │
│                 │                     │                     │ register is used regardless of the operation size.                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ADDX            │    Dn, Dn           │  8, 16, 32          │ Source + Destination + X → Destination                                                   │
│                 │ -(An), -(An)        │  8, 16, 32          │                                                                                          │
│                 │                     │                     │ Adds the source operand and the extend bit to the destination operand and stores the     │
│                 │                     │                     │ result in the destination location. The operands can be addressed in two different ways: │
│                 │                     │                     │ 1. Data register to data register—The data registers specified in the instruction contain│
│                 │                     │                     │ the operands.                                                                            │
│                 │                     │                     │ 2. Memory to memory—The address registers specified in the instruction address the       │
│                 │                     │                     │ operands using the predecrement addressing mode.                                         │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ The size of the operation can be specified as byte, word, or long.                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ CLR             │     <ea>            │  8, 16, 32          │ 0 → Destination                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ CMP             │ <ea>, Dn            │  8, 16, 32          │ Destination - Source                                                                     │
│ CMPA            │ <ea>, An            │     16, 32          │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ CMPI            │ #<data>, <ea>       │  8, 16, 32          │ Destination - Immediate Data                                                             │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ CMPM            │ (An)+, (An)+        │  8, 16, 32          │ Destination - Source                                                                     │
│                 │                     │                     │ Compare multiple                                                                         │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ CMP2            │ <ea>, Rn            │  8, 16, 32          │ Lower Bound → Rn → Upper Bound                                                           │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ DIVS/DIVU       │ <ea>, Dn            │ 32 ÷ 16 → 16, 16    │ Destination ÷ Source → Destination                                                       │
│                 │ <ea>, Dr-Dq         │ 64 ÷ 32 → 32, 32    │ (Signed or Unsigned Quotient, Remainder)                                                 │
│                 │ <ea>, Dq            │ 32 ÷ 32 → 32        │                                                                                          │
│                 │                     │                     │                                                                                          │
│ DIVSL/DIVUL     │ <ea>, Dr - Dq       │ 32 ÷ 32 → 32, 32    │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ EXT             │      Dn             │  8 → 16             │ Sign-Extended Destination → Destination                                                  │
│                 │      Dn             │  16 → 32            │                                                                                          │
│ EXTB            │      Dn             │  8 → 32             │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MULS/MULU       │ <ea>, Dn            │ 16 x 16 → 32        │ Source x Destination → Destination                                                       │
│                 │ <ea>, Dl            │ 32 x 32 → 32        │ (Signed or Unsigned)                                                                     │
│                 │ <ea>, Dh - Dl       │ 32 x 32 → 64        │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│  NEG            │ <ea>                │ 8, 16, 32           │ 0 - Destination → Destination                                                            │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│  NEGX           │ <ea>                │ 8, 16, 32           │ 0 - Destination - X → Destination                                                        │
│                 │                     │                     │ Negate with Extend                                                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ SUB             │ <ea>, Dn            │ 8, 16, 32           │ Destination = Source → Destination                                                       │
│                 │ Dn, <ea>            │ 8, 16, 32           │                                                                                          │
│ SUBA            │ <ea>, An            │    16, 32           │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ SUBI            │ #<data>, <ea>       │ 8, 16, 32           │ Destination - Immediate Data → Destination                                               │
│ SUBQ            │ #<data>, <ea>       │ 8, 16, 32           │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ SUBX            │  Dn, Dn             │ 8, 16, 32           │ Destination - Source - X → Destination                                                   │
│                 │  -(An), -(An)       │ 8, 16, 32           │ Subtract with Extend                                                                     │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘

# Logical Instructions
The logical operation instructions (AND, OR, EOR, and NOT) perform logical operations with all sizes of integer data operands. A similar set of immediate instructions (ANDI, ORI, and EORI) provides these logical operations with all sizes of immediate data. Table 3-4 summarizes the logical operations.

┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Instruction     ┃ Operand Syntax      ┃ Operand Size        ┃                    Operation                                                             ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│     AND         │ <ea>, Dn            │  8, 16, 32          │ Source ۸ Destination → Destination                                                       │
│                 │ Dn, <ea>            │  8, 16, 32          │                                                                                          │
│                 │                     │                     │ Performs an AND operation of the source operand with the destination operand and stores  │
│                 │                     │                     │ the result in the destination location. The size of the operation can be specified as    │
│                 │                     │                     │ byte, word, or long. The contents of an address register may not be used as an operand.  │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ NOTE                                                                                     │
│                 │                     │                     │  Most assemblers use ANDI when the source is immediate data. The Dn mode is used when    │
│                 │                     │                     │  the destination is a data register; the destination < ea > mode is invalid for a data   │
│                 │                     │                     │  register.                                                                               │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Condition Codes: XNZVC                                                                   │
│                 │                     │                     │ X — Not affected.                                                                        │
│                 │                     │                     │ N — Set if the most significant bit of the result is set; cleared otherwise.             │
│                 │                     │                     │ Z — Set if the result is zero; cleared otherwise.                                        │ 
│                 │                     │                     │ V — Always cleared.                                                                      │
│                 │                     │                     │ C — Always cleared.                                                                      │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│    ANDI         │ #<data>, <ea>       │  8, 16, 32          │ Immediate Data ۸ Destination → Destination                                               │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Performs an AND operation of the immediate data with the destination operand and stores  │
│                 │                     │                     │ the result in the destination location. The size of the operation can be specified as    │
│                 │                     │                     │ byte, word, or long. The size of the immediate data matches the operation size.          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Condition Codes: XNZVC                                                                   │
│                 │                     │                     │ X — Not affected.                                                                        │
│                 │                     │                     │ N — Set if the most significant bit of the result is set; cleared otherwise.             │
│                 │                     │                     │ Z — Set if the result is zero; cleared otherwise.                                        │ 
│                 │                     │                     │ V — Always cleared.                                                                      │
│                 │                     │                     │ C — Always cleared.                                                                      │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│    EOR          │ Dn, <ea>            │  8, 16, 32          │ Source ⊕ Destination → Destination                                                       │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│    EORI         │ #<data>, <ea>       │  8, 16, 32          │ Immediate Data ⊕ Destination → Destination                                               │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│    NOT          │ <ea>                │  8, 16, 32          │ ~ Destination → Destination                                                              │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│    OR           │ <ea>, Dn            │  8, 16, 32          │ Source ۷ Destination → Destination                                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│    ORI          │ #<data>, <ea>       │  8, 16, 32          │ Immediate Data ۷ Destination → Destination                                               │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘

# Shift and Rotation Instructions
The ASR, ASL, LSR, and LSL instructions provide shift operations in both directions. The ROR, ROL, ROXR, and ROXL instructions perform rotate (circular shift) operations, with and without the CCR extend bit (X-bit). All shift and rotate operations can be performed on either registers or memory.
Register shift and rotate operations shift all operand sizes. The shift count can be specified in the instruction operation word (to shift from 1 – 8 places) or in a register (modulo 64 shift count).
Memory shift and rotate operations shift word operands one bit position only. The SWAP instruction exchanges the 16-bit halves of a register. Fast byte swapping is possible by using the ROR and ROL instructions with a shift count of eight, enhancing the performance of the shift/rotate instructions. Table 3-5 is a summary of the shift and rotate operations. In Table 3-5, C and X refer to the C-bit and X- bit in the CCR.

┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Instruction     ┃ Operand Syntax      ┃ Operand Size        ┃                    Operation                                                             ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│                 │                     │                     │  Shifts off into the sign extention and carry bits of CCR                                │
│                 │ Dn, Dn              │ 8, 16, 32           │   ---      -------------                                                                 │
│  ASL            │ #<data>, Dn         │ 8, 16, 32           │  |X/C| ◀--| ◀---------- | ◀-- 0                                                          │
│                 │    <ea>             │    16               │   ---      -------------                                                                 │
│                 │                     │                     │  Arithmetic Shift Left                                                                   │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Arithmetically shifts the bits of the operand in the direction (L or R) specified. The carry bit receives the last bit shifted out of the operand. The shift count for the shifting of a register may be specified in two different ways:
│                 │                     │                     │ 1. Immediate—The shift count is specified in the instruction (shift range, 1 – 8).
│                 │                     │                     │ 2. Register—The shift count is the value in the data register specified in instruction modulo 64.
│                 │                     │                     │ The size of the operation can be specified as byte, word, or long. An operand in mem- ory can be shifted one bit only, and the operand size is restricted to a word.
│                 │                     │                     │ For ASL, the operand is shifted left; the number of positions shifted is the shift count. Bits shifted out of the high-order bit go to both the carry and the extend bits; zeros are shifted into the low-order bit. The overflow bit indicates if any sign changes occur dur- ing the shift.
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ For ASR, the operand is shifted right; the number of positions shifted is the shift count. Bits shifted out of the low-order bit go to both the carry and the extend bits; the sign bit (MSB) is shifted into the high-order bit.                                                                                         │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Condition Codes:                                                                         │
│                 │                     │                     │ 
│                 │                     │                     │  X — Set according to the last bit shifted out of the operand; unaffected for a shift count of zero.
│                 │                     │                     │  N — Set if the most significant bit of the result is set; cleared otherwise.
│                 │                     │                     │  Z — Set if the result is zero; cleared otherwise.
│                 │                     │                     │  V — Set if the most significant bit is changed at any time during the shift operation;
│                 │                     │                     │  cleared otherwise.
│                 │                     │                     │  C — Set according to the last bit shifted out of the operand; cleared for a shift count
│                 │                     │                     │  of zero.                                                                                │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │ Shifts off into the sign extention and carry bits of CCR                                 │
│                 │                     │                     │             -------------       ---                                                      │
│                 │  Dn, Dn             │  8, 16, 32          │       ---▶ | ----------▶ | --▶ |X/C|                                                     │
│                 │  #<data>, Dn        │  8, 16, 32          │      |      -------------       ---                                                      │
│ ASR             │     <ea>            │     16              │      |      |                                                                            │
│                 │                     │                     │        -----                                                                             │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Arithmetic Shift Right                                                                   │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │ Shifts off into the sign extention and carry bits of CCR                                 │
│                 │ Dn, Dn              │ 8, 16, 32           │   ---      -------------                                                                 │
│  LSL            │ #<data>, Dn         │ 8, 16, 32           │  |X/C| ◀--| ◀---------- | ◀-- 0                                                          │
│                 │    <ea>             │    16               │   ---      -------------                                                                 │
│                 │                     │                     │ Logical Shift Left                                                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │ Shifts off into the sign extention and carry bits of CCR                                 │
│                 │ Dn, Dn              │ 8, 16, 32           │         -------------       ---                                                          │
│  LSR            │ #<data>, Dn         │ 8, 16, 32           │  0 --▶ | ----------▶ | --▶ |X/C|                                                         │
│                 │    <ea>             │    16               │         -------------       ---                                                          │
│                 │                     │                     │ Logical Shift Right                                                                      │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │ Rotates off into the carry bit of CCR                                                    │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │           --------------------                                                           │
│                 │ Dn, Dn              │ 8, 16, 32           │   ---    |  -------------     |                                                          │
│  ROL            │ #<data>, Dn         │ 8, 16, 32           │  | C | ◀---| ◀---------- | ◀--                                                           │
│                 │    <ea>             │    16               │   ---       -------------                                                                │
│                 │                     │                     │ Rotate Left                                                                              │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │ Rotates off into the carry bit of CCR                                                    │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │   ---------------------                                                                  │
│                 │ Dn, Dn              │ 8, 16, 32           │  |     -------------   |    ---                                                          │
│  ROR            │ #<data>, Dn         │ 8, 16, 32           │   --▶ | ----------▶ | ---▶ | C |                                                         │
│                 │    <ea>             │    16               │        -------------        ---                                                          │
│                 │                     │                     │ Rotate Right                                                                             │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │ Rotates off into the carry bit of CCR. Rotates the extended bit in.                      │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │           ------------------------------                                                 │
│                 │ Dn, Dn              │ 8, 16, 32           │   ---    |  -------------       ---     |                                                │
│  ROXL           │ #<data>, Dn         │ 8, 16, 32           │  | C | ◀---| ◀---------- | ◀-- | X | ◀--                                                 │
│                 │    <ea>             │    16               │   ---       -------------       ---                                                      │
│                 │                     │                     │ Rotate Extended Left                                                                     │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │ Rotates off into the carry bit of CCR. Roates the extended bit in.                       │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │   -------------------------------                                                        │
│                 │ Dn, Dn              │ 8, 16, 32           │  |     ---       -------------   |    ---                                                │
│  ROXR           │ #<data>, Dn         │ 8, 16, 32           │  ---▶ | X | --▶ | ----------> | ---▶ | C |                                               │
│                 │    <ea>             │    16               │        ---       -------------        ---                                                │
│                 │                     │                     │ Rotate Extended Right                                                                    │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ SWAP            │ Dn                  │   32                │                                                                                          │
│                 │                     │                     │               ----                                                                       │
│                 │                     │                     │              |    ▼                                                                      │
│                 │                     │                     │            -----------                                                                   │
│                 │                     │                     │           | MSW | LSW |                                                                  │
│                 │                     │                     │            -----------                                                                   │
│                 │                     │                     │              ▲    |                                                                      │
│                 │                     │                     │               ----                                                                       │
│                 │                     │                     │  Swaps the most significant word with the least significant word                         │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘
NOTE: X indicates the extend bit and C the carry bit in the CCR.

# Bit Manipulation Instructions
BTST, BSET, BCLR, and BCHG are bit manipulation instructions. All bit manipulation operations can be performed on either registers or memory. The bit number is specified either as immediate data or in the contents of a data register. Register operands are 32 bits long, and memory operands are 8 bits long. Table 3-6 summarizes bit manipulation operations; Z refers to the zero bit of the CCR.

                                            Bit Manipulation Operation Format
┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Instruction     ┃ Operand Syntax      ┃ Operand Size        ┃                    Operation                                                             ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│ BCHG            │ Dn, <ea>            │  8, 32              │ ~(<Bit Number> of Destination) → Z →                                                     │
│                 │ #<data>, <ea>       │  8, 32              │ Bit of Destination                                                                       │
│                 │                     │                     │ Bit CHanGe                                                                               │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Description: Tests a bit in the destination operand and sets the Z condition code appropriately, then inverts the specified bit in the destination. When the destination is a data register, any of the 32 bits can be specified by the modulo 32-bit number. When the destination is a memory location, the operation is a byte operation, and the bit number is modulo 8. In all cases, bit zero refers to the least significant bit. The bit number for this operation may be specified in either of two ways:
│                 │                     │                     │   1. Immediate—The bit number is specified in a second word of the instruction.          │
│                 │                     │                     │   2. Register—The specified data register contains the bit number.                       │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BCLR            │ Dn, <ea>            │  8, 32              │ ~(<Bit Number> of Destination) → Z;                                                      │
│                 │ #<data>, <ea>       │  8, 32              │ 0 → Bit of Destination                                                                   │
│                 │                     │                     │ Bit CLeaR?                                                                               │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ TEST (<bit number> of Destination) → Z; 0 → <bit number> of Destination                  │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Description: Tests a bit in the destination operand and sets the Z condition code appropriately, then clears the specified bit in the destination. When a data register is the destination, any of the 32 bits can be specified by a modulo 32-bit number. When a memory location is the destination, the operation is a byte operation, and the bit number is modulo 8. In all cases, bit zero refers to the least significant bit. The bit number for this operation can be specified in either of two ways:
│                 │                     │                     │     1. Immediate—The bit number is specified in a second word of the instruction.
│                 │                     │                     │     2. Register—The specified data register contains the bit number.                     │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BSET            │ Dn, <ea>            │  8, 32              │ ~(<Bit Number> of Destination) → Z;                                                      │
│                 │ #<data>, <ea>       │  8, 32              │ 1 → Bit of Destination                                                                   │
│                 │                     │                     │ Bit SET                                                                                  │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ TEST ( < bit number > of Destination) → Z; 1 → < bit number > of Des- tination           │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Tests a bit in the destination operand and sets the Z condition code appropriately, then sets the specified bit in the destination operand. When a data register is the destination, any of the 32 bits can be specified by a modulo 32-bit number. When a memory location is the destination, the operation is a byte operation, and the bit number is modulo 8. In all cases, bit zero refers to the least significant bit. The bit number for this operation can be specified in either of two ways:
│                 │                     │                     │     1. Immediate—The bit number is specified in the second word of the instruction.      │
│                 │                     │                     │     2. Register—The specified data register contains the bit number.                     │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │    XNZVC                                                                                 │
│                 │                     │                     │    X — Not affected.                                                                     │
│                 │                     │                     │    N — Not affected.                                                                     │
│                 │                     │                     │    Z — Set if the bit tested is zero; cleared otherwise.                                 │
│                 │                     │                     │    V — Not affected.                                                                     │
│                 │                     │                     │    C — Not affected.                                                                     │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BTST            │ Dn, <ea>            │  8, 32              │ ~(<Bit Number> of Destination) → Z                                                       │
│                 │ #<data>, <ea>       │  8, 32              │                                                                                          │
│                 │                     │                     │ Bit TeST, Test a Bit                                                                     │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Description: Tests a bit in the destination operand and sets the Z condition code appropriately. When a data register is the destination, any of the 32 bits can be specified by a modulo 32- bit number. When a memory location is the destination, the operation is a byte operation, and the bit number is modulo 8. In all cases, bit zero refers to the least significant bit. The bit number for this operation can be specified in either of two ways:
│                 │                     │                     │  1. Immediate—The bit number is specified in a second word of the instruction.           │
│                 │                     │                     │  2. Register—The specified data register contains the bit number.                        │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │  X — Not affected.                                                                       │
│                 │                     │                     │  N — Not affected.                                                                       │
│                 │                     │                     │  Z — Set if the bit tested is zero; cleared otherwise.                                   │
│                 │                     │                     │  V — Not affected.                                                                       │
│                 │                     │                     │  C — Not affected.                                                                       │
│                 │                     │                     │                                                                                          │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘

# Bit Field Instructions
The M68000 family architecture supports variable-length bit field operations on fields of up to 32 bits. The BFINS instruction inserts a value into a bit field. BFEXTU and BFEXTS extract a value from the field. BFFFO finds the first set bit in a bit field. Also included are instructions analogous to the bit manipulation operations: BFTST, BFSET, BFCLR, and BFCHG. Table 3-7 summarizes bit field operations.
One of the data types provided by the MC68030 is the bit field, consisting of as many as 32 consecutive bits. An offset from an effective address and a width value defines a bit field. The offset is a value in the range of – 231 through 231 – 1 from the most significant bit (bit 7) at the effective address. The width is a positive number, 1 through 32. The most significant bit of a bit field is bit 0. The bits number in a direction opposite to the bits of an integer.
The instruction set includes eight instructions that have bit field operands. The insert bit field (BFINS) instruction inserts a bit field stored in a register into a bit field. The extract bit field signed (BFEXTS) instruction loads a bit field into the least significant bits of a register and extends the sign to the left, filling the register. The extract bit field unsigned (BFEXTU) also loads a bit field, but zero fills the unused portion of the destination register.

The set bit field (BFSET) instruction sets all the bits of a field to ones. The clear bit field (BFCLR) instruction clears a field. The change bit field (BFCHG) instruction complements all the bits in a bit field. These three instructions all test the previous value of the bit field, setting the condition codes accordingly. The test bit field (BFTST) instruction tests the value in the field, setting the condition codes appropriately without altering the bit field. The find first one in bit field (BFFFO) instruction scans a bit field from bit 0 to the right until it finds a bit set to one and loads the bit offset of the first set bit into the specified data register. If no bits in the field are set, the field offset and the field width is loaded into the register.

An important application of bit field instructions is the manipulation of the exponent field in a floating-point number. In the IEEE standard format, the most significant bit is the sign bit of the mantissa. The exponent value begins at the next most significant bit position; the exponent field does not begin on a byte boundary. The extract bit field (BFEXTU) instruction and the BFTST instruction are the most useful for this application, but other bit field instructions can also be used.

Programming of input and output operations to peripherals requires testing, setting, and inserting of bit fields in the control registers of the peripherals. This is another application for bit field instructions. However, control register locations are not memory locations; therefore, it is not always possible to insert or extract bit fields of a register without affecting other fields within the register.

Another widely used application for bit field instructions is bit- mapped graphics. Because byte boundaries are ignored in these areas of memory, the field definitions used with bit field instructions are very helpful.

                                                    Bit Field Operation Format
┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Instruction     ┃ Operand Syntax      ┃ Operand Size        ┃                    Operation                                                             ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│ BFCHG           │ <ea>{offset:width}  │  1 - 32             │ ~ Field → Field                                                                          │
│                 │                     │                     │ Bit Field CHanGe                                                                         │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ TEST ( < bit field > of Destination) → < bit field > of Destination                      │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Sets the condition codes according to the value in a bit field at the specified effective address, then complements the field.
│                 │                     │                     │ A field offset and a field width select the field. The field offset specifies the starting bit of the field. The field width determines the number of bits in the field.                                                                                         │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ X — Not affected.                                                                        │ 
│                 │                     │                     │ N — Set if the most significant bit of the field is set; cleared otherwise.              │
│                 │                     │                     │ Z — Set if all bits of the field are zero; cleared otherwise.                            │
│                 │                     │                     │ V — Always cleared.                                                                      │
│                 │                     │                     │ C — Always cleared.                                                                      │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BFCLR           │ <ea> {offset:width} │  1 - 32             │ 0's → Field                                                                              │
│                 │                     │                     │ Bit Field CLeaR                                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ 0 → <bit field> of Destination                                                           │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │  Sets condition codes according to the value in a bit field at the specified effective address and clears the field.
│                 │                     │                     │  The field offset and field width select the field. The field offset specifies the starting bit of the field. The field width determines the number of bits in the field.│
│                 │                     │                     │                                                                                          │
│                 │                     │                     │  Condition Codes
│                 │                     │                     │  X — Not affected.
│                 │                     │                     │  N — Set if the most significant bit of the field is set; cleared otherwise. Z — Set if all bits of the field are zero; cleared otherwise.
│                 │                     │                     │  V — Always cleared.
│                 │                     │                     │  C — Always cleared.
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BFEXTS          │<ea>{offset:width},Dn│  1 - 32             │ Field → Dn; Sign-Extended                                                                │
│                 │                     │                     │ Bit Field EXTend Sign                                                                    │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Extract Bit Field Signed                                                                 │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Extracts a bit field from the specified effective address location, sign extends to 32 bits, and loads the result into the destination data register. The field offset and field width select the bit field. The field offset specifies the starting bit of the field. The field width determines the number of bits in the field.│
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ X — Not affected.
│                 │                     │                     │ N — Set if the most significant bit of the field is set; cleared otherwise. 
│                 │                     │                     │ Z — Set if all bits of the field are zero; cleared otherwise.
│                 │                     │                     │ V — Always cleared.
│                 │                     │                     │ C — Always cleared.                                                                      │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BFEXTU          │<ea>{offset:width},Dn│  1 - 32             │ Field → Dn; Zero-Extended                                                                │
│                 │                     │                     │ Bit Field EXTend Unsigned                                                                │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Extract Bit Field Unsigned                                                               │
│                 │                     │                     │ Extracts a bit field from the specified effective address location, zero extends to 32 bits, and loads the results into the destination data register. The field offset and field width select the field. The field offset specifies the starting bit of the field. The field width determines the number of bits in the field.│
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ X — Not affected.                                                                        │
│                 │                     │                     │ N — Set if the most significant bit of the source field is set; cleared otherwise.       │
│                 │                     │                     │ Z — Set if all bits of the field are zero; cleared otherwise.                            │
│                 │                     │                     │ V — Always cleared.                                                                      │
│                 │                     │                     │ C — Always cleared.                                                                      │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BFFFO           │<ea>{offset:width},Dn│  1 - 32             │ Scan for First Bit Set in Field; Offset → Dn.                                            │
│                 │                     │                     │ Bit Field First Field Offset?                                                            │
│                 │                     │                     │ <bit offset> of Source Bit Scan → Dn                                                     │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Searches the source operand for the most significant bit that is set to a value of one. The bit offset of that bit (the bit offset in the instruction plus the offset of the first one bit) is placed in Dn. If no bit in the bit field is set to one, the value in Dn is the field offset plus the field width. The instruction sets the condition codes according to the bit field value. The field offset and field width select the field. The field offset specifies the starting bit of the field. The field width determines the number of bits in the field. │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Condition Codes:                                                                         │
│                 │                     │                     │  XNZVC                                                                                   │
│                 │                     │                     │  X — Not affected.                                                                       │
│                 │                     │                     │  N — Set if the most significant bit of the field is set; cleared otherwise. Z — Set if all bits of the field are zero; cleared otherwise.
│                 │                     │                     │  V — Always cleared.                                                                     │
│                 │                     │                     │  C — Always cleared.                                                                     │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BFINS           │Dn,<ea>{offset:width}│  1 - 32             │ Dn → Field                                                                               │
│                 │                     │                     │ Bit Field INSert?                                                                        │
│                 │                     │                     │ Dn → < bit field > of Destination                                                        │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Inserts a bit field taken from the low-order bits of the specified data register into a bit field at the effective address location. The instruction sets the condition codes according to the inserted value. The field offset and field width select the field. The field offset specifies the starting bit of the field. The field width determines the number of bits in the field. │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Condition Codes:                                                                         │
│                 │                     │                     │  XNZVC                                                                                   │
│                 │                     │                     │  X — Not affected.                                                                       │
│                 │                     │                     │  N — Set if the most significant bit of the field is set; cleared otherwise. Z — Set if all bits of the field are zero; cleared otherwise.
│                 │                     │                     │  V — Always cleared.                                                                     │
│                 │                     │                     │  C — Always cleared.                                                                     │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BFSET           │ <ea>{offset,width}  │  1 - 32             │ 1's → Field                                                                              │
│                 │                     │                     │ Bit Field SET?                                                                           │
│                 │                     │                     │ Write 1's starting at some offset till width?                                            │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ 1 → <bit field> of Destination                                                           │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Sets the condition codes according to the value in a bit field at the specified effective address, then sets each bit in the field.
│                 │                     │                     │ The field offset and the field width select the field. The field offset specifies the starting bit of the field. The field width determines the number of bits in the field. │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Condition Codes:                                                                         │
│                 │                     │                     │     XNZVC                                                                                │
│                 │                     │                     │     X — Not affected.                                                                    │
│                 │                     │                     │     N — Set if the most significant bit of the field is set; cleared otherwise.          │
│                 │                     │                     │     Z — Set if all bits of the field are zero; cleared otherwise.                        │   
│                 │                     │                     │     V — Always cleared.                                                                  │
│                 │                     │                     │     C — Always cleared.                                                                  │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BFTST           │ <ea>{offset:width}  │  1 - 32             │ Field MSB → N; ~ (OR of all Bits in Field) R → Z                                         │
│                 │                     │                     │ Bit Field TeST                                                                           │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Sets the condition codes according to the value in a bit field at the specified effective address location. The field offset and field width select the field. The field offset specifies the starting bit of the field. The field width determines the number of bits in the field. │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Condition Codes:                                                                         │
│                 │                     │                     │    XNZVC                                                                                 │
│                 │                     │                     │    X — Not affected.                                                                     │
│                 │                     │                     │    N — Set if the most significant bit of the field is set; cleared otherwise.           │
│                 │                     │                     │    Z — Set if all bits of the field are zero; cleared otherwise.                         │
│                 │                     │                     │    V — Always cleared.                                                                   │
│                 │                     │                     │    C — Always cleared.                                                                   │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘
NOTE: All bit field instructions set the CCR N and Z bits as shown for BFTST before performing the specified operation.

# Binary-Coded Decimal Instructions
Five instructions support operations on binary-coded decimal (BCD) numbers. The arithmetic operations on packed BCD numbers are ABCD, SBCD, and NBCD. PACK and UNPK instructions aid in the conversion of byte-encoded numeric data, such as ASCII or EBCDIC strings to BCD data and vice versa. Table 3-8 summarizes BCD operations. In Table 3- 8 X refers to the X-bit in the CCR.

                                                Binary-Coded Decimal Operation Format 
┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃   Instruction   ┃    Operand Syntax   ┃    Operand Size     ┃                                     Operation                                            ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│ ABCD            │ Dn, Dn              │         8           │ Source   + Destination   + X → Destination                                               │
│                 │ -(An), -(An)        │         8           │       10              10                                                                 │
│                 │                     │                     │ Add Binary-Coded Decimal                                                                 │
│                 │                     │                     │ Add Decimal with Extend                                                                  │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Description: Adds the source operand to the destination operand along with the extend    │
│                 │                     │                     │ bit, and stores the result in the destination location. The addition is performed using  │
│                 │                     │                     │ binary-coded decimal arithmetic. The operands, which are packed binary-coded decimal     │
│                 │                     │                     │ numbers, can be addressed in two different ways:                                         │
│                 │                     │                     │ 1. Data Register to Data Register: The operands are contained in the data registers      │
│                 │                     │                     │    specified in the instruction.                                                         │
│                 │                     │                     │ 2. Memory to Memory: The operands are addressed with the predecrement ad- dressing mode  │
│                 │                     │                     │    using the address registers specified in the instruction.                             │
│                 │                     │                     │ This operation is a byte operation only.                                                 │
│                 │                     │                     │ Condition Codes:                                                                         │
│                 │                     │                     │   X   N   Z   V   C                                                                      │
│                 │                     │                     │ ┌───┬───┬───┬───┬───┐                                                                    │
│                 │                     │                     │ │ * │ U │ * │ U │ * │                                                                    │
│                 │                     │                     │ └───┴───┴───┴───┴───┘                                                                    │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │  X - Set the same as the carry bit.                                                      │
│                 │                     │                     │  N - Undefined                                                                           │
│                 │                     │                     │  Z - Cleared if the result is nonzero; unchanged otherwise.                              │
│                 │                     │                     │  V - Undefined                                                                           │
│                 │                     │                     │  C - Set if a decimal carry was generated; cleared otherwise.                            │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Note                                                                                     │
│                 │                     │                     │ Normally, the Z condition code bit is set via programming before the start of an operatio│
│                 │                     │                     │ This allows successful tests for zero results upon completion of multiple-prcision       │
│                 │                     │                     │ operations.                                                                              │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │  15  14  13  12   11   10   9   8   7   6   5   4   3   2   1   0                        │
│                 │                     │                     │ ┌───┬───┬───┬───┬─────────────┬───┬───┬───┬───┬───┬───┬─────────────┐                    │
│                 │                     │                     │ │ 1 │ 1 │ 0 │ 0 │ Register Rx │ 1 │ 0 │ 0 │ 0 │ 0 │R/M│ Register Ry │                    │
│                 │                     │                     │ └───┴───┴───┴───┴─────────────┴───┴───┴───┴───┴───┴───┴─────────────┘                    │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Instruction Fields:                                                                      │
│                 │                     │                     │     Register Rx field—Specifies the destination register.                                │
│                 │                     │                     │         If R/M = 0, specifies a data register.                                           │
│                 │                     │                     │         If R/M = 1, specifies an address register for the predecrement addressing mode.  │
│                 │                     │                     │     R/M field—Specifies the operand addressing mode.                                     │
│                 │                     │                     │         0 - The operation is data register to data register.                             │
│                 │                     │                     │         1 - The operation is memory to memory.                                           │
│                 │                     │                     │     Register Ry field—Specifies the source register.                                     │
│                 │                     │                     │        If R/M = 0, specifies a data register.                                            │
│                 │                     │                     │         If R/M = 1, specifies an address register for the predecrement addressing mode.  │                                                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ NBCD            │     <ea>            │         8           │ 0 - Destination   - X → Destination                                                      │
│                 │                     │                     │                10                                                                        │
│                 │                     │                     │ Natural Binary-Coded Decimal                                                             │
│                 │                     │                     │ X is the X-bit of the CCR                                                                │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ BCD takes advantage of the fact that any one decimal numeral can be represented by a     │
│                 │                     │                     │ four bit pattern. The most obvious way of encoding digits is "natural BCD" (NBCD), where │
│                 │                     │                     │ each decimal digit is represented by its corresponding four-bit binary value, as shown   │
│                 │                     │                     │ in the following table. This is also called "8421" encoding.                             │
│                 │                     │                     │  ┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓                                                     │
│                 │                     │                     │  ┃                 ┃      BCD      ┃                                                     │
│                 │                     │                     │  ┃ Decimal digit   ┣━━━┯━━━┯━━━┯━━━┫                                                     │
│                 │                     │                     │  │                 ┃ 8 │ 4 │ 2 │ 1 ┃                                                     │
│                 │                     │                     │  ┣━━━━━━━━━━━━━━━━━╋━━━┿━━━┿━━━┿━━━┫                                                     │
│                 │                     │                     │  │       0         │ 0 │ 0 │ 0 │ 0 │                                                     │
│                 │                     │                     │  ├─────────────────┼───┼───┼───┼───┤                                                     │
│                 │                     │                     │  │       1         │ 0 │ 0 │ 0 │ 1 │                                                     │
│                 │                     │                     │  ├─────────────────┼───┼───┼───┼───┤                                                     │
│                 │                     │                     │  │       2         │ 0 │ 0 │ 1 │ 0 │                                                     │
│                 │                     │                     │  ├─────────────────┼───┼───┼───┼───┤                                                     │
│                 │                     │                     │  │       3         │ 0 │ 0 │ 1 │ 1 │                                                     │
│                 │                     │                     │  ├─────────────────┼───┼───┼───┼───┤                                                     │
│                 │                     │                     │  │       4         │ 0 │ 1 │ 0 │ 0 │                                                     │
│                 │                     │                     │  ├─────────────────┼───┼───┼───┼───┤                                                     │
│                 │                     │                     │  │       5         │ 0 │ 1 │ 0 │ 1 │                                                     │
│                 │                     │                     │  ├─────────────────┼───┼───┼───┼───┤                                                     │
│                 │                     │                     │  │       6         │ 0 │ 1 │ 1 │ 0 │                                                     │
│                 │                     │                     │  ├─────────────────┼───┼───┼───┼───┤                                                     │
│                 │                     │                     │  │       7         │ 0 │ 1 │ 1 │ 1 │                                                     │
│                 │                     │                     │  ├─────────────────┼───┼───┼───┼───┤                                                     │
│                 │                     │                     │  │       8         │ 1 │ 0 │ 0 │ 0 │                                                     │
│                 │                     │                     │  ├─────────────────┼───┼───┼───┼───┤                                                     │
│                 │                     │                     │  │       9         │ 1 │ 0 │ 0 │ 1 │                                                     │
│                 │                     │                     │  └─────────────────┴───┴───┴───┴───┘                                                     │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Unpacked: Each numeral is encoded into one byte, with four bits representing the numeral │
│                 │                     │                     │ and the remaining bits having no significance.                                           │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Packed: Two numerals are encoded into a single byte, with one numeral in the least       │
│                 │                     │                     │ significant nibble (bits 0 through 3) and the other numeral in the most significant      │
│                 │                     │                     │ nibble (bits 4 through 7).                                                               │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ https://en.wikipedia.org/wiki/Binary-coded_decimal                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ PACK            │ -(An), -(An) #<data>│    16 → 8           │ Unpackaged Source + Immediate Data → Packed                                              │
│                 │ Dn, Dn, #<data>     │    16 → 8           │ Destination                                                                              │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ SBCD            │  Dn, Dn             │       8             │ Destination   - Source   - X → Destination                                               │
│                 │  -(An), -(An)       │       8             │            10         10                                                                 │
│                 │                     │                     │ Subtract Binary-Coded Decimal                                                            │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ UNPK            │ -(An), -(An) #<data>│    8 → 16           │ Packed Source → Unpacked Source                                                          │
│                 │  Dn, Dn, #<data>    │    8 → 16           │ Unpacked Source + Immediate Data → Unpacked Destination                                  │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ UNPacK                                                                                   │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘

# Program Control Instructions
A set of subroutine call and return instructions and conditional and unconditional branch instructions perform program control operations. Also included are test operand instructions (TST and FTST), which set the integer or floating-point condition codes for use by other program and system control instructions. NOP forces synchronization of the internal pipelines. Table 3-9 summarizes these instructions.

┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃   Instruction   ┃    Operand Syntax   ┃    Operand Size     ┃                                     Operation                                            ┃
┣━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│                                              Integer and Floating-Point Conditional                                                                    │
├─────────────────┬─────────────────────┬─────────────────────┬──────────────────────────────────────────────────────────────────────────────────────────┤
│  Bcc, FBcc      │   <label>           │   8, 16, 32         │ If Condition True, Then PC + dn → PC                                                     │
│                 │                     │                     │ Branch carry clear                                                                       │
│                 │                     │                     │ Floating Branch carry clear                                                              │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Description: If the specified condition is true, program execution continues at location (PC) + displacement. The program counter contains the address of the instruction word for the Bcc instruction plus two. The displacement is a twos-complement integer that represents the relative distance in bytes from the current program counter to the destination program counter. If the 8-bit displacement field in the instruction word is zero, a 16-bit displacement (the word immediately following the instruction) is used. If the 8-bit displacement field in the instruction word is all ones ($FF), the 32-bit displacement (long word immediately following the instruction) is used. Condition code cc specifies one of the following conditional tests (refer to Table 3-19 for more information on these conditional tests): │
│                 │                     │                     │ (and bccs) Branch Conditionally                                                          │
│                 │                     │                     │ bcc	<ea>	carry clear                                                                  │
│                 │                     │                     │ bcs	<ea>	carry set                                                                    │
│                 │                     │                     │ beq	<ea>	equal                                                                        │
│                 │                     │                     │ bge	<ea>	greater or equal                                                             │
│                 │                     │                     │ bgt	<ea>	greater than                                                                 │
│                 │                     │                     │ bhi	<ea>	high                                                                         │
│                 │                     │                     │ ble	<ea>	less or equal                                                                │
│                 │                     │                     │ bls	<ea>	low or same                                                                  │
│                 │                     │                     │ blt	<ea>	less than                                                                    │
│                 │                     │                     │ bmi	<ea>	minus                                                                        │
│                 │                     │                     │ bne	<ea>	not equal                                                                    │
│                 │                     │                     │ bpl	<ea>	plus                                                                         │
│                 │                     │                     │ bvc	<ea>	overflow clear                                                               │
│                 │                     │                     │ bvs	<ea>	overflow set                                                                 │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ DBcc, FDBcc     │ Dn, <label>         │      16             │ If Condition False, Then Dn - 1 → Dn                                                     │
│                 │                     │                     │ If Dn → -1, Then _c + dn → PC                                                            │
│                 │                     │                     │  fdbcc Floating-Point Test Condition,                                                    │
│                 │                     │                     │  fdb{condition_code} Dn,<ea> Decrement, and Branch                                       │
│                 │                     │                     │ http://www.nextcomputers.org/NeXTfiles/Docs/NeXTStep/3.3/nd/Assembler/Part2_ArchSpecific/M68k_Instructions.htmld/index.html │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ Scc, FScc       │   <ea>              │      8              │ If Condition True, 1's → Destination;                                                    │
│                 │                     │                     │ Else 0's → Destination                                                                   │
│                 │                     │                     │ Set According to Condition                                                               │
├─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┤
│                                                  Unconditional                                                                                         │
├─────────────────┬─────────────────────┬─────────────────────┬──────────────────────────────────────────────────────────────────────────────────────────┤
│ BRA             │  <label>            │  8, 16, 32          │ PC + dn → PC                                                                             │
│                 │                     │                     │ BRanch Always                                                                            │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ BRA <label>                                                                              │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Description: Program execution continues at location (PC) + displacement. The program counter contains the address of the instruction word of the BRA instruction plus two. The displacement is a twos complement integer that represents the relative distance in bytes from the current program counter to the destination program counter. If the 8-bit displacement field in the instruction word is zero, a 16-bit displacement (the word immediately following the instruction) is used. If the 8-bit displacement field in the instruction word is all ones ($FF), the 32-bit displacement (long word immediately following the instruction) is used.
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BSR             │ <label>             │  8, 16, 32          │ SP - 4 → SP; PC → (SP); PC + dn → PC                                                     │
│                 │                     │                     │ Branch to SubRoutine                                                                     │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Pushes the long-word address of the instruction immediately following the BSR instruction onto the system stack. The program counter contains the address of the instruction word plus two. Program execution then continues at location (PC) + displacement. The displacement is a twos complement integer that represents the relative distance in bytes from the current program counter to the destination program counter. If the 8-bit displacement field in the instruction word is zero, a 16-bit displacement (the word immediately following the instruction) is used. If the 8-bit displacement field in the instruction word is all ones ($FF), the 32-bit displacement (long word immediately following the instruction) is used.                                                                                         │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ JMP             │ <ea>                │     none            │ Destination → PC                                                                         │
│                 │                     │                     │ JuMP                                                                                     │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ JSR             │ <ea>                │     none            │ SP - 4 SP; PC → (SP); Destination → PC                                                   │
│                 │                     │                     │	Jump to SubRoutine                                                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ NOP             │   none              │     none            │ PC + 2 → PC (Integer Pipeline Synchronized)                                              │
│                 │                     │                     │	No OPeration                                                                             │
│                 │                     │                     │	Although the no operation (NOP) instruction performs no visible operation, it serves an  │
│                 │                     │                     │ important purpose. It forces synchronization of the integer unit pipeline by waiting for │
│                 │                     │                     │	all pending bus cycles to complete. All previous integer instructions and floating-point │
│                 │                     │                     │ external operand accesses complete execution before the NOP begins. The NOP instruction  │
│                 │                     │                     │	does not synchronize the FPU pipeline—floating- point instructions with floating-point   │
│                 │                     │                     │	register operand destinations can be executing when the NOP begins. NOP is considered a  │
│                 │                     │                     │	change of flow instruction and traps for trace on change of flow. A single- cycle        │
│                 │                     │                     │	nonsynchronizing operation can be affected with the TRAPF instruction.                   │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FNOP            │   none              │     none            │ PC + 4 → PC (FPU Pipeline Synchronized)                                                  │
│                 │                     │                     │ Float No OPeration                                                                       │
├─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┤
│                                                  Returns                                                                                               │
├─────────────────┬─────────────────────┬─────────────────────┬──────────────────────────────────────────────────────────────────────────────────────────┤
│ RTD             │ #<data>             │     16              │ (SP) → PC; SP + 4 + dn → SP                                                              │
│                 │                     │                     │ Return and Deallocate                                                                    │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ RTR             │ none                │  none               │ (SP) → CCR; SP + 2 → SP; (SP) → PC; SP + 4 → SP                                          │
│                 │                     │                     │ Return and Restore Condition Codes                                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ RTS             │ none                │ none                │ (SP) → PC; SP + 4 → SP                                                                   │
│                 │                     │                     │ ReTurn from Subroutine                                                                   │
├─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┤
│                                                  Test Operand                                                                                          │
├─────────────────┬─────────────────────┬─────────────────────┬──────────────────────────────────────────────────────────────────────────────────────────┤
│ TST             │  <ea>               │  8, 16, 32          │ Set Integer Condition Codes                                                              │
│                 │                     │                     │ Test an Operand                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FTST            │ <ea>                │ B, W, L, S, D, X, P │ Set Floating-Point Condition Codes                                                       │
│                 │ FPn                 │        X            │ Test Floating-Point Operand                                                              │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ CALLM           │#<data>, <ea>        │ Unsized             │ Call Module                                                                              │
│                 │                     │                     │  Save Current Module State on Stack; Load New Module State from Destination              │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ The effective address of the instruction is the location of an external module descriptor. A module frame is created on the top of the stack, and the current module state is saved in the frame. The immediate operand specifies the number of bytes of arguments to be passed to the called module. A new module state is loaded from the descriptor addressed by the effective address.                                                                                         │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘
Letters cc in the integer instruction mnemonics Bcc, DBcc, and Scc specify testing one of the following conditions:
CC — Carry clear          GE — Greater than or equal
LS — Lower or same        PL — Plus
CS — Carry set            GT — Greater than 
LT — Less than            T  — Always true*
EQ — Equal                HI — Higher
MI — Minus                VC — Overflow clear
F  — Never true*          LE — Less than or equal
NE — Not equal            VS — Overflow set

*Not applicable to the Bcc instructions.

# System Control Instructions 
Privileged and trapping instructions as well as instructions that use or modify the CCR provide system control operations. FSAVE and FRESTORE save and restore the nonuser visible portion of the FPU during context switches in a virtual memory or multitasking system. The conditional trap instructions, which use the same conditional tests as their corresponding program control instructions, allow an optional 16- or 32-bit immediate operand to be included as part of the instruction for passing parameters to the operating system. These instructions cause the processor to flush the instruction pipe. Table 3-10 summarizes these instructions. See 3.2 Integer Unit Condition Code Computation for more details on condition codes.

                                                    System Control Operation Format
┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃   Instruction   ┃    Operand Syntax   ┃    Operand Size     ┃                                     Operation                                            ┃
┣━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│                                                             Privileged                                                                                 │
├─────────────────┬─────────────────────┬─────────────────────┬──────────────────────────────────────────────────────────────────────────────────────────┤
│ANDI to SR       │ #<data>, SR         │       16            │ Immediate Data ۸ SR → SR                                                                 │
│                 │                     │                     │ AND Immediate to Status Register                                                         │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ EORI to SR      │ #<data>, SR         │       16            │ Immediate Data ⊕ SR → SR                                                                 │
│                 │                     │                     │ Exclusive-OR Immediate to Status Register                                                │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FRESTORE        │ <ea>                │    none             │ State Frame → Internal Floating-Point Registers                                          │
│                 │                     │                     │ Restore Internal Floating-Point State                                                    │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FSAVE           │ <ea>                │    none             │ Internal Floating-Point Registers → State Frame                                          │
│                 │                     │                     │ Save Internal Floating-Point State                                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MOVE to SR      │ <ea>, SR            │      16             │ Source → SR                                                                              │
│                 │                     │                     │ MOVE to Status Register                                                                  │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MOVE from SR    │ SR, <ea>            │      16             │ SR → Destination                                                                         │
│                 │                     │                     │ MOVE from Status Register                                                                │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MOVE USP        │ USP, An             │      32             │ USP → An                                                                                 │
│                 │ An, USP             │      32             │ An → USP                                                                                 │
│                 │                     │                     │ MOVE User Stack Pointer                                                                  │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MOVEC           │ Rc, Rn              │      32             │ Rc → Rn                                                                                  │
│                 │ Rn, Rc              │      32             │ Rn → Rc                                                                                  │
│                 │                     │                     │ Move Control Register                                                                    │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MOVES           │ Rn, <ea>            │   8, 16, 32         │ Rn → Destination Using DFC                                                               │
│                 │ <ea>, Rn            │                     │ Source Using SFC → Rn                                                                    │
│                 │                     │                     │ MOVE address Space                                                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ORI to SR       │ #<data>, SR         │      16             │ Immediate Data ۷ SR → SR                                                                 │
│                 │                     │                     │ Inclusive-OR Immediate to the Status Register                                            │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ RESET           │ none                │ none                │ Assert Reset Output                                                                      │
│                 │                     │                     │ Reset External Devices                                                                   │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ RTE             │ none                │ none                │ (SP) → SR; SP + 2 → SP; (SP) → PC; SP + 4 → SP;                                          │
│                 │                     │                     │ Restore Stack According to format                                                        │
│                 │                     │                     │ Return from Exception                                                                    │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ STOP            │ #<data>             │       16            │ Immediate Data → SR; STOP                                                                │
│                 │                     │                     │ Load Status Register and Stop                                                            │
├─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┤
│                                                  Trap Generating                                                                                       │
├─────────────────┬─────────────────────┬─────────────────────┬──────────────────────────────────────────────────────────────────────────────────────────┤
│ BKPT            │ #<data>             │ none                │ Run Breakpoint Cycle                                                                     │
│                 │                     │                     │ Breakpoint                                                                               │
│                 │                     │                     │ BKPT #<data>                                                                             │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Description: For the MC68010, a breakpoint acknowledge bus cycle is run with function codes driven high and zeros on all address lines. Whether the breakpoint acknowledge bus cycle is terminated with DTACK, BERR, or VPA, the processor always takes an illegal instruction exception. During exception processing, a debug monitor can distinguish different software breakpoints by decoding the field in the BKPT instruction. For the MC68000 and MC68008, the breakpoint cycle is not run, but an illegal instruction exception is taken.
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ CHK             │ <ea>, Dn            │   16, 32            │ If Dn < 0 or Dn > (<ea>), Then CHK Exception                                             │
│                 │                     │                     │ Check Register Against Bounds                                                            │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ CHK <ea> ,Dn                                                                             │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Description: Compares the value in the data register specified in the instruction to zero and to the upper bound (effective address operand). The upper bound is a twos complement integer. If the register value is less than zero or greater than the upper bound, a CHK instruction exception (vector number 6) occurs.                                                                                         │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │  X — Not affected.                                                                       │
│                 │                     │                     │  N — Set if Dn < 0; cleared if Dn > effective address operand; undefined otherwise. Z — Undefined.
│                 │                     │                     │  V — Undefined.                                                                          │
│                 │                     │                     │  C — Undefined.                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ CHK2            │ <ea>, Rn            │  8, 16, 32          │ If Rn < Lower Bound or Rn > Upper Bound, Then CHK Exception                              │
│                 │                     │                     │ Check Register Against Bounds                                                            │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ If Rn <LB or Rn> UB Then TRAP                                                            │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ Description: Compares the value in Rn to each bound. The effective address contains the bounds pair: the upper bound following the lower bound. For signed comparisons, the arithmetically smaller value should be used as the lower bound. For unsigned comparisons, the logically smaller value should be the lower bound.
│                 │                     │                     │ The size of the data and the bounds can be specified as byte, word, or long. If Rn is a data register and the operation size is byte or word, only the appropriate low-order part of Rn is checked. If Rn is an address register and the operation size is byte or word, the bounds operands are sign-extended to 32 bits, and the resultant operands are compared to the full 32 bits of An.
│                 │                     │                     │ If the upper bound equals the lower bound, the valid range is a single value. If the reg-ister value is less than the lower bound or greater than the upper bound, a CHK instruc- tion exception (vector number 6) occurs.                                                                                         │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │  X — Not affected.                                                                       │
│                 │                     │                     │  N — Undefined.                                                                          │
│                 │                     │                     │  Z — Set if Rn is equal to either bound; cleared otherwise. V — Undefined.               │
│                 │                     │                     │  C — Set if Rn is out of bounds; cleared otherwise.                                      │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ILLEGAL         │    none             │  none               │ SSP - 2 → SSP; Vector Offset → (SSP);                                                    │
│                 │                     │                     │ SSP - 4 → SSP; PC → (SSP);                                                               │
│                 │                     │                     │ SSP - 2 → SSP; SR → (SSP);                                                               │
│                 │                     │                     │ Illegal Instruction Vector Address → PC                                                  │
│                 │                     │                     │ Take Illegal Instruction Trap                                                            │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ TRAP            │ #<data>             │ none                │ SSP - 2 → SSP; Format and Vector Offset → (SSP)                                          │
│                 │                     │                     │ SSP - 4 → SSP; PC → (SSP); SSP - 2 → SSP;                                                │
│                 │                     │                     │ SR → (SSP); Vector Address → PC                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ TRAPcc          │ none                │ none                │ If cc True, Then Trap Exception                                                          │
│                 │ #<data>             │ 16, 32              │ Trap on Condition (Unsized)                                                              │
│                 │                     │                     │ TRAP carry clear                                                                         │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FTRAPcc         │ none                │ none                │ If Floating-Point cc True, Then Trap Exception                                           │
│                 │ #<data>             │ 16, 32              │ Trap on Floating-Point condition                                                         │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ TRAPV           │ none                │ none                │ If V, Then Take Overflow Trap Exception                                                  │
│                 │                     │                     │ Trap on Overflow                                                                         │
├─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┤
│                                                  Condition Code Register                                                                               │
├─────────────────┬─────────────────────┬─────────────────────┬──────────────────────────────────────────────────────────────────────────────────────────┤
│ ANDI to SR      │ #<data>, CCR        │       8             │ Immediate Data ۸ CCR → CCR                                                               │
│                 │                     │                     │ AND Immediate to Status Register                                                         │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ EORI to SR      │ #<data>, CCR        │       8             │ Immediate Data ⊕ CCR → CCR                                                               │
│                 │                     │                     │ Exclusive-OR Immediate to Status Register                                                │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MOVE to SR      │ <ea>, CCR           │      16             │ Source → CCR                                                                             │
│                 │                     │                     │ MOVE to Status Register                                                                  │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MOVE from SR    │ CCR, <ea>           │      16             │ CCR → Destination                                                                        │
│                 │                     │                     │ MOVE from Status Register                                                                │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ORI to SR       │ #<data>, CCR        │       8             │ Immediate Data ۷ CCR → CCR                                                               │
│                 │                     │                     │ OR Immediate to Status Register                                                          │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘
Letters cc in the TRAPcc and FTRAPcc specify testing for a condition.

# Multiprocessor Instructions
The TAS, CAS, and CAS2 instructions coordinate the operations of processors in multiprocessing systems. These instructions use read-modify-write bus cycles to ensure uninterrupted updating of memory. Coprocessor instructions control the coprocessor operations. Table 3- 12 summarizes these instructions.

                                                    Multiporcessor Operations
┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃   Instruction   ┃    Operand Syntax   ┃    Operand Size     ┃                                     Operation                                            ┃
┣━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│                                                    Read-Write-Modify                                                                                   │
├─────────────────┬─────────────────────┬─────────────────────┬──────────────────────────────────────────────────────────────────────────────────────────┤
│ CAS             │ Dc, Du, <ea>        │  8, 16, 32          │ Destination - Dc → CC                                                                    │
│                 │                     │                     │ If Z, Then Du → Destination                                                              │
│                 │                     │                     │ Else Destination → Dc                                                                    │
│                 │                     │                     │ Compare and Swap with Operand                                                            │
│                 │                     │                     │                                                                                          │
│                 │                     │                     │ The CAS instruction compares the value in a memory location with the value in a data     │
│                 │                     │                     │ register, and copies a second data register into the memory location if the compared     │
│                 │                     │                     │ values are equal. This provides a means of updating system counters, history information,│
│                 │                     │                     │ and globally shared pointers. The instruction uses an indivisible read-modify-write      │
│                 │                     │                     │ cycle. After CAS reads the memory location, no other instruction can change that location│
│                 │                     │                     │ before CAS has written the new value. This provides security in single-processor systems,│
│                 │                     │                     │ in multitasking environments, and in multiprocessor environments. In a single-processor  │
│                 │                     │                     │ system, then operation is protected from instructions of an interrupt routine. In a      │
│                 │                     │                     │ multitasking environment, no other task can interfere with writing the new value of a    │
│                 │                     │                     │ system variable. In a multiprocessor environment, the other processors must wait until   │
│                 │                     │                     │ the CAS instruction completes before accessing a global pointer.                         │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ CAS2            │ Dc1-Dc2, Du1-Du2,   │    16, 32           │ Dual Operand CAS                                                                         │
│                 │   (Rn)-(Rn)         │                     │ Compare and Swap with Operand                                                            │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ TAS             │     <ea>            │      8              │ Destination - 0; Set Condition Codes;                                                    │
│                 │                     │                     │ 1 → Destination [7]                                                                      │
├─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┤
│                                                       Coprocessor                                                                                      │
├─────────────────┬─────────────────────┬─────────────────────┬──────────────────────────────────────────────────────────────────────────────────────────┤
│ cpBcc           │  <label>            │    16, 32           │  If cpcc True, Then PC + dn → PC                                                         │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ cpDBcc          │  <label> Dn         │      16             │ If cpcc False, Then Dn - 1 → Dn                                                          │
│                 │                     │                     │ If Dn != -1, Then PC + dn → PC                                                           │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ cpGEN           │  User Defined       │ User Defined        │ Operand → Coprocessor                                                                    │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ cpRESTORE       │   <ea>              │    none             │ Restore Coprocessor State from <ea>                                                      │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ cpSAVE          │   <ea>              │    none             │ Sace Coprocessor State at <ea>                                                           │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ cpScc           │   <ea>              │      8              │ If cpcc True, Then 1's → Destination;                                                    │
│                 │                     │                     │ Else 0's → Destination;                                                                  │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ cpTRAPcc        │   none              │     none            │ If cpcc True, Then TRAPcc Exception                                                      │
│                 │   #<data>           │     16, 32          │                                                                                          │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘


# Floating-Point Arithmetic Instructions
The following paragraphs describe the floating-point instructions, organized into two categories of operation: dyadic (requiring two operands) and monadic (requiring one operand).
The dyadic floating-point instructions provide several arithmetic functions that require two input operands, such as add and subtract. For these operations, the first operand can be located in memory, an integer data register, or a floating-point data register. The second operand is always located in a floating-point data register. The results of the operation store in the register specified as the second operand. All FPU operations support all data formats. Results are rounded to either extended-, single-, or double-precision format. Table 3-14 gives the general format of dyadic instructions, and Table 3-15 lists the available operations.

                                                   Dyadic Floating-Point Operation Format 
┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃   Instruction   ┃    Operand Syntax   ┃    Operand Size     ┃                                     Operation                                            ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│ F<dop>          │ <ea>, FPn           │ B, W, L, S, D, X, P │ FPn <Function> Source → FPn                                                              │
│                 │ FPm, FPn            │        X            │                                                                                          │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘
NOTE: < dop > is any one of the dyadic operation specifiers.

# Floating-Point Operations
The following paragraphs describe the floating-point instructions, organized into two categories of operation: dyadic (requiring two operands) and monadic (requiring one operand).

The dyadic floating-point instructions provide several arithmetic functions that require two input operands, such as add and subtract. For these operations, the first operand can be located in memory, an integer data register, or a floating-point data register. The second operand is always located in a floating-point data register. The results of the operation store in the register specified as the second operand. All FPU operations support all data formats. Results are rounded to either extended-, single-, or double-precision format. Table 3-14 gives the general format of dyadic instructions, and Table 3-15 lists the available operations.

                                                Dyadic Floating-Point Operations
┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃   Instruction   ┃    Operand Syntax   ┃    Operand Size     ┃                                     Operation                                            ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│ FADD            │ <ea>, FPn           │b, w, l, s, d, x, p  │                                                                                          │
│                 │ FPn, FPn            │x                    │                                                                                          │
│                 │ FPn                 │x                    │ Floating-Point Add                                                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FCMP            │ <ea>, FPn           │ b, w, l, s, d, x, p │ Floating-Point Compare                                                                   │
│                 │ FPn, FPn            │ x                   │                                                                                          │
│                 │ FPn                 │ x                   │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FDIV            │ <ea>, FPn           │ b, w, l, s, d, x, p │ Floating-Point Divide                                                                    │
│                 │ FPn, FPn            │ x                   │                                                                                          │
│                 │ FPn                 │ x                   │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FMOD            │ <ea>, FPn           │ b, w, l, s, d, x, p │ Modulo Remainder                                                                         │
│                 │ FPn, FPn            │ x                   │                                                                                          │
│                 │ FPn                 │ x                   │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FMUL            │ <ea>, FPn           │ b, w, l, s, d, x, p │ Floating-Point Multiply                                                                  │
│                 │ FPn, FPn            │ x                   │                                                                                          │
│                 │ FPn                 │ x                   │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FREM            │ <ea>, FPn           │ b, w, l, s, d, x, p │ IEEE Remainder                                                                           │
│                 │ FPn, FPn            │ x                   │                                                                                          │
│                 │ FPn                 │ x                   │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FSCALE          │ <ea>, FPn           │ b, w, l, s, d, x, p │ Scale Exponent                                                                           │
│                 │ FPn, FPn            │ x                   │                                                                                          │
│                 │ FPn                 │ x                   │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FSUB            │ <ea>, FPn           │ b, w, l, s, d, x, p │ Floating-Point Subtract                                                                  │
│                 │ FPn, FPn            │ x                   │                                                                                          │
│                 │ FPn                 │ x                   │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FSGLDIV         │ <ea>, FPn           │ b, w, l, s, d, x, p │ Single Precision Divide                                                                  │
│                 │ FPn, FPn            │ x                   │                                                                                          │
│                 │ FPn                 │ x                   │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FSGLMUL         │ <ea>, FPn           │ b, w, l, s, d, x, p │ Single Precision Multiply                                                                │
│                 │ FPn, FPn            │ x                   │                                                                                          │
│                 │ FPn                 │ x                   │                                                                                          │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘


# Monadic Floating-Point Operation Format
The monadic floating-point instructions provide several arithmetic functions requiring only one input operand. Unlike the integer counterparts to these functions (e.g., NEG < ea > ), a source and a destination can be specified. The operation is performed on the source operand and the result is stored in the destination, which is always a floating-point data register. When the source is not a floating-point data register, all data formats are supported. The data format is always extended precision for register-to-register operations. Table 3-16 lists the general format of these instructions, and Table 3-17 lists the available operations.

┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃   Instruction   ┃    Operand Syntax   ┃    Operand Format   ┃                                     Operation                                            ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│ FABS            │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Floating-Point Absolute Value                                                            │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FACOS           │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Floating-Point Arc Cosine                                                                │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FASIN           │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Floating-Point Arc Sine                                                                  │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FATAN           │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Floating-Point Hyperbolic Arc Tangent                                                    │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FCOS            │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Floating-Point Cosine                                                                    │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FCOSH           │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Floating-Point Hyperbolic Cosine                                                         │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FETOX           │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Floating-Point e^x                                                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FETOXM1         │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Floating-Point e^x - 1                                                                   │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FGETEXP         │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Floating-Point Extract Exponent, Get Exponent                                            │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FGETMAN         │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Extract Mantissa                                                                         │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FINT            │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Extract Integer Part                                                                     │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FINTRZ          │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Extract Integer Part, Rounded-to-Zero                                                    │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FLOGN           │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ ln(x); Natural Log; Log base e                                                           │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FLOGNP1         │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ ln(x + 1)                                                                                │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FLOG10          │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ log10(x); log base 10 of x                                                               │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FLOG2           │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Log2(x); log base 2 of x                                                                 │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FNEG            │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Negate                                                                                   │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FSIN            │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Sine                                                                                     │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FSINH           │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Hyperbolic Sine                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FSQRT           │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Square Root                                                                              │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FTAN            │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Tangent                                                                                  │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FTANH           │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ Hyperbolic Tangent                                                                       │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FTENTOX         │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ 10^x                                                                                     │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ FTWOTOX         │ <ea>, FPn           │B, W, L, S, D, X, P  │ Source → Function → FPn                                                                  │
│                 │ FPm, FPn            │         X           │                                                                                          │
│                 │   FPn               │         X           │ FPn → Function FPn                                                                       │
│                 │                     │                     │ 2^x                                                                                      │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘

# INTEGER UNIT CONDITION CODE COMPUTATION
Many integer instructions affect the CCR to indicate the instruction's results. Program and system control instructions also use certain combinations of these bits to control program and system flow. The condition codes meet consistency criteria across instructions, uses, and instances. They also meet the criteria of meaningful results, where no change occurs unless it provides useful information. Refer to Section 1 Introduction for details concerning the CCR.

Table 3-18 lists the integer condition code computations for instructions and Table 3-19 lists the condition names, encodings, and tests for the conditional branch and set instructions. The test associated with each condition is a logical formula using the current states of the condition codes. If this formula evaluates to one, the condition is true. If the formula evaluates to zero, the condition is false. For example, the T condition is always true, and the EQ condition is true only if the Z-bit condition code is currently true.

                                        Integer Unit Condition Code Computations
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━┳━━━━━┳━━━━━┳━━━━━┳━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃       Operations              ┃  X  ┃  N  ┃  Z  ┃  V  ┃  C  ┃                                     Operation                                            ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╋━━━━━╋━━━━━╋━━━━━╋━━━━━╋━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│ ABCD                          │  *  │  U  │  ?  │  U  │  ?  │ C = Decimal Carry                                                                        │
│                               │     │     │     │     │     │         __        __                                                                     │
│                               │     │     │     │     │     │ Z = Z ۸ Rm ۸ ...۸ R0                                                                     │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ADD, ADDI, ADDQ               │  *  │  *  │  *  │  ?  │  ?  │               __   __   __                                                               │
│                               │     │     │     │     │     │ V = Sm ۸ Dm ۸ Rm ۷ Sm ۸ Dm ۸ Rm                                                          │
│                               │     │     │     │     │     │               __             __                                                          │
│                               │     │     │     │     │     │ C = Sm ۸ Dm ۷ Rm ۸ Dm ۷ Sm ۸ Rm                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ADDX                          │  *  │  *  │  ?  │  ?  │  ?  │                __   __   __                                                              │
│                               │     │     │     │     │     │  V = Sm ۸ Dm ۸ Rm ۷ Sm ۸ Dm ۸ Rm                                                         │
│                               │     │     │     │     │     │                __             __                                                         │
│                               │     │     │     │     │     │  C = Sm ۸ Dm ۷ Rm ۸ Dm ۷ Sm ۸ Rm                                                         │
│                               │     │     │     │     │     │          __        __                                                                    │
│                               │     │     │     │     │     │  Z = Z ۸ Rm ۸ ...۸ R0                                                                    │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ AND, ANDI, EOR, EORI, MOVEQ   │  -  │  *  │  *  │  0  │  0  │                                                                                          │
│ MOVE, OR, ORI, CLR, EXT, EXTB,│     │     │     │     │     │                                                                                          │
│ NOT, TAS, TST                 │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ CHK                           │  -  │  *  │  U  │  U  │  U  │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ CHK2, CMP2                    │  _  │  U  │  ?  │  U  │  ?  │ Z = (R = LB) ۷ (R = UB)                                                                  │
│                               │     │     │     │     │     │ C = (LB <= UB) ۸ (IR < LB) ۷ (R > UB) ۷ (UB < LB) ۸ (R > UB) ۸ (R < LB)                  │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ SUB, SUBI, SUBQ               │  *  │  *  │  *  │  ?  │  ?  │     __        __        __                                                               │
│                               │     │     │     │     │     │ V = Sm ۸ Dm ۸ Rm ۷ Sm ۸ Dm ۸ Rm                                                          │
│                               │     │     │     │     │     │          __        __                                                                    │
│                               │     │     │     │     │     │ C = Sm ۸ Dm ۷ Rm ۸ Dm ۷ Sm ۸ Rm                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ SUBX                          │  *  │  *  │  ?  │  ?  │  ?  │     __        __        __                                                               │
│                               │     │     │     │     │     │ V = Sm ۸ Dm ۸ Rm ۷ Sm ۸ Dm ۸ Rm                                                          │
│                               │     │     │     │     │     │          __        __                                                                    │
│                               │     │     │     │     │     │ C = Sm ۸ Dm ۷ Rm ۸ Dm ۷ Sm ۸ Rm                                                          │
│                               │     │     │     │     │     │         __        __                                                                     │
│                               │     │     │     │     │     │ Z = Z ۸ Rm ۸ ...۸ R0                                                                     │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ CAS, CAS2, CMP, CMPA, CMPI,   │  -  │  *  │  *  │  ?  │  ?  │     __        __        __                                                               │
│ CMPM                          │     │     │     │     │     │ V = Sm ۸ Dm ۸ Rm ۷ Sm ۸ Dm ۸ Rm                                                          │
│                               │     │     │     │     │     │          __        __                                                                    │
│                               │     │     │     │     │     │ C = Sm ۸ Dm ۷ Rm ۸ Dm ۷ Sm ۸ Rm                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ DIVS, DIVU                    │  -  │  *  │  *  │  ?  │  0  │ V - Division Overflow                                                                    │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ MULS, MULU                    │  -  │  *  │  *  │  ?  │  0  │ V = Multiplication Overflow                                                              │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ SBCD, NBCD                    │  *  │  U  │  ?  │  U  │  ?  │ C - Decimal Borrow                                                                       │
│                               │     │     │     │     │     │         __       __                                                                      │
│                               │     │     │     │     │     │ Z = Z ۸ Rm ۸...۸ R0                                                                      │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ NEG                           │  *  │  *  │  *  │  ?  │  ?  │ V = Dm ۸ Rm                                                                              │
│                               │     │     │     │     │     │ C = Dm ۷ Rm                                                                              │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ NEGX                          │  *  │  *  │  ?  │  ?  │  ?  │ V = Dm ۸ Rm                                                                              │
│                               │     │     │     │     │     │ C = Dm ۷ Rm                                                                              │
│                               │     │     │     │     │     │         __       __                                                                      │
│                               │     │     │     │     │     │ Z = Z ۸ Rm ۸...۸ R0                                                                      │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BTST, BCHG, BSET, BCLR        │  -  │  -  │  ?  │  -  │  -  │     __                                                                                   │
│                               │     │     │     │     │     │ Z = Dn                                                                                   │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BFTST, BFCHG, BFSET, BFCLR    │  -  │  ?  │  ?  │  0  │  0  │ N = Dm                                                                                   │
│                               │     │     │     │     │     │     __   ___        __                                                                   │
│                               │     │     │     │     │     │ Z = Dn ۸ Dm-1 ۸...۸ D0                                                                   │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BFEXTS, BFEXTU, BFFFO         │  -  │  ?  │  ?  │  0  │  0  │ N = Sm                                                                                   │
│                               │     │     │     │     │     │          ___        __                                                                   │
│                               │     │     │     │     │     │ Z = Sm ۸ Sm-1 ۸...۸ S0                                                                   │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ BFINS                         │  _  │  ?  │  ?  │  0  │  0  │ N = Dm                                                                                   │
│                               │     │     │     │     │     │     __   ___        __                                                                   │
│                               │     │     │     │     │     │ Z = Dm ۸ Dm-1 ۸...۸ D0                                                                   │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ASL                           │  *  │  *  │  *  │  ?  │  ?  │          ___        ___    __                                                            │
│                               │     │     │     │     │     │ V = Dm ۸ Dm-1 ۷...۷ Dm-r ۷ Dm ۸ (DM-1 ۷...+ Dm - r)                                      │
│                               │     │     │     │     │     │     __ ___                                                                               │
│                               │     │     │     │     │     │ C = Dm-r+1                                                                               │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ASL (r = 0)                   │  -  │  *  │  *  │  0  │  0  │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ LSL, ROXL                     │  *  │  *  │  *  │  0  │  ?  │ C = Dm -r + 1                                                                            │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ LSR (r=0)                     │  -  │  *  │  *  │  0  │  0  │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ROXL (r = 0)                  │  -  │  *  │  *  │  0  │  ?  │ X = C                                                                                    │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ROL                           │  -  │  *  │  *  │  0  │  ?  │ C = Dm - r + 1                                                                           │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ROL (r = 0)                   │  -  │  *  │  *  │  0  │  0  │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ASR, LSR, ROXR                │  *  │  *  │  *  │  0  │  ?  │ C = Dr - 1                                                                               │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ASR, LSR (r = 0)              │  -  │  *  │  *  │  0  │  0  │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ROXR (r = 0)                  │  -  │  *  │  *  │  0  │  ?  │ X = C                                                                                    │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ROR                           │  -  │  *  │  *  │  0  │  ?  │ C = Dr - 1                                                                               │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ ROR (r = 0)                   │  -  │  *  │  *  │  0  │  0  │                                                                                          │
└───────────────────────────────┴─────┴─────┴─────┴─────┴─────┴──────────────────────────────────────────────────────────────────────────────────────────┘
? = Other—See Special Definition
N = Result Operand (MSB)
    __       __
Z = Rm Λ...Λ R0
Sm = Source Operand (MSB)
Dm = Destination Operand (MSB)
Rm = Result Operand (MSB)
__
Rm = Not Result Operand (MSB)
R = Register Tested
r = Shift Count

# Conditonal Tests
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Mnemonic ┃   Condition      ┃ Encoding ┃       Test            ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
│   T*     │   True           │   0000   │        1              │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│   F*     │   False          │   0001   │        0              │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│          │                  │          │      _   _            │
│   HI     │   High           │   0010   │      C ۸ Z            │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│   LS     │ Low or Same      │   0011   │      C ۷ Z            │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│ CC(HI)   │ Carry Clear      │   0100   │        C              │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│ CS(LO)   │ Carry Set        │   0101   │        C              │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│   NE     │ Not Equal        │   0110   │        Z              │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│   EQ     │ Equal            │   0111   │        Z              │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│   VC     │ Overflow Clear   │   1000   │        V              │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│   VS     │ Overflow Set     │   1001   │        V              │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│   PL     │ Plus             │   1010   │        N              │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│   MI     │ Minus            │   1011   │        N              │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│          │                  │          │         _   _         │
│   GE     │ Greater or Equal │   1100   │ N ۸ V ۷ N ۸ V         │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│          │                  │          │     _   _             │
│   LT     │ Less Than        │   1101   │ N ۸ V ۷ N ۸ V         │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│          │                  │          │         _   _   _   _ │
│   GT     │ Greater Than     │   1110   │ N ۸ V ۷ Z ۷ N ۸ V ۸ Z │
├──────────┼──────────────────┼──────────┼───────────────────────┤
│          │                  │          │         _   _         │
│   LE     │ Less or Equal    │   1111   │ Z ۷ N ۸ V ۷ N ۸ V     │
└──────────┴──────────────────┴──────────┴───────────────────────┘
NOTES:
_
N = Logical Not N
_
V = Logical Not V
_
Z = Logical Not Z
*Not available for the Bcc instruction.


Figure 3-1 illustrates the intermediate result format. The intermediate result’s exponent for some dyadic operations (i.e., multiply and divide) can easily overflow or underflow the 15- bit exponent of the designation floating-point register. To simplify the overflow and underflow detection, intermediate results in the FPU maintain a 16-bit (17 bits for the MC68881 and MC68882), twos complement, integer exponent. Detection of an overflow or underflow intermediate result always converts the 16-bit exponent into a 15-bit biased exponent before being stored in a floating-point data register. The FPU internally maintains the 67-bit mantissa for rounding purposes. The mantissa is always rounded to 64 bits (or less, depending on the selected rounding precision) before it is stored in a floating-point data register.
If the destination is a floating-point data register, the result is in the extended-precision format and is rounded to the precision specified by the FPSR PREC bits before being stored. All mantissa bits beyond the selected precision are zero. If the single- or double-precision mode is selected, the exponent value is in the correct range even if it is stored in extended- precision format. If the destination is a memory location, the FPSR PREC bits are ignored. In this case, a number in the extended-precision format is taken from the source floating- point data register, rounded to the destination format precision, and then written to memory.
Depending on the selected rounding mode or destination data format in effect, the location of the least significant bit of the mantissa and the locations of the guard, round, and sticky bits in the 67-bit intermediate result mantissa varies. The guard and round bits are always calculated exactly. The sticky bit is used to create the illusion of an infinitely wide intermediate result. As the arrow illustrates in Figure 3-1, the sticky bit is the logical OR of all the bits in the infinitely precise result to the right of the round bit. During the calculation stage of an arithmetic operation, any non-zero bits generated that are to the right of the round bit set the sticky bit to one. Because of the sticky bit, the rounded intermediate result for all required IEEE arithmetic operations in the RN mode is in error by no more than one half unit in the last place.

## Figure 3-1 Intermediate Result Format
                                                           ┌────┐ 
                                                           ▼    │
┌─────────────────┬─┬─┬───────────────────────────────┬─┬─┬─┐   │
│ 16-BIT Exponent │ ┊ ┊        63-BIT Mantissa        ┊ ┊ ┊ │ ──┘
└─────────────────┴─┴─┴───────────────────────────────┴─┴─┴─┘
                   │ │              LSB of Fraction ─┘ │ │ │
                   │ └─ Integer Bit       Guard Bit ───┘ │ │
                   └─── Overflow bit      Round Bit ─────┘ │
                                         Sticky Bit ───────┘

## Rounding the Result
The FPU supports the four rounding modes specified by the IEEE 754 standard. These modes are round to nearest (RN), round toward zero (RZ), round toward plus infinity (RP), and round toward minus infinity (RM). The RM and RP rounding modes are often referred to as "directed rounding modes" and are useful in interval arithmetic. Rounding is accomplished through the intermediate result. Single-precision results are rounded to a 24- bit boundary; double-precision results are rounded to a 53-bit boundary; and extended- precision results are rounded to a 64-bit boundary. Table 3-21 lists the encodings for the FPCR that denote the rounding and precision modes.

FPCR Encodings

┏━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Rounding Mode           ┃ Encoding  ┃ Rounding Precisionst     ┃
┃ (RND Field)             ┃           ┃     (PREC Field)         ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━╋━━━━━┳━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│ To Nearest (RN)         │  0  │  0  │ Extend (X)               │
├─────────────────────────┼─────┼─────┼──────────────────────────┤
│ To Zero (RZ)            │  0  │  1  │ Single (S)               │
├─────────────────────────┼─────┼─────┼──────────────────────────┤
│ To Minus Inifinity (RM) │  1  │  0  │ Double (D)               │
├─────────────────────────┼─────┼─────┼──────────────────────────┤
│ To Plus Infinity (RP)   │  1  │  1  │ Undifined                │
└─────────────────────────┴─────┴─────┴──────────────────────────┘


## FPCC Encodings
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━┳━━━━━┳━━━━━┳━━━━━━━┓
┃           Data Type          ┃  N  ┃  Z  ┃  I  ┃  NAN  ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╋━━━━━╋━━━━━╋━━━━━╋━━━━━━━┫
│ + Normalized or Denormalized │  0  │  0  │  0  │   0   │
├──────────────────────────────┼─────┼─────┼─────┼───────┤
│ - Normalized or Denormalized │  1  │  0  │  0  │   0   │
├──────────────────────────────┼─────┼─────┼─────┼───────┤
│ + 0                          │  0  │  1  │  0  │   0   │
├──────────────────────────────┼─────┼─────┼─────┼───────┤
│ - 0                          │  1  │  1  │  0  │   0   │
├──────────────────────────────┼─────┼─────┼─────┼───────┤
│ + Infinity                   │  0  │  0  │  1  │   0   │
├──────────────────────────────┼─────┼─────┼─────┼───────┤
│ - Infinity                   │  1  │  0  │  1  │   0   │
├──────────────────────────────┼─────┼─────┼─────┼───────┤
│ + NAN                        │  0  │  0  │  0  │   1   │
├──────────────────────────────┼─────┼─────┼─────┼───────┤
│ - NAN                        │  1  │  0  │  0  │   1   │
└──────────────────────────────┴─────┴─────┴─────┴───────┘

## Floating-point Conditional Testing
The inclusion of the unordered condition in floating-point branches destroys the familiar trichotomy relationship (greater than, equal, less than) that exists for integers. For example, the opposite of floating-point branch greater than (FBGT) is not floating-point branch less than or equal (FBLE). Rather, the opposite condition is floating-point branch not greater than (FBNGT). If the result of the previous instruction was unordered, FBNGT is true; whereas, both FBGT and FBLE would be false since unordered fails both of these tests (and sets BSUN).



│          │                  │          │    │                     │
├──────────┼──────────────────┼──────────┼────┼─────────────────────┤
│          │                  │          │    │                     │
├──────────┼──────────────────┼──────────┼────┼─────────────────────┤
│          │                  │          │    │                     │
├──────────┼──────────────────┼──────────┼────┼─────────────────────┤
│          │                  │          │    │                     │
├──────────┼──────────────────┼──────────┼────┼─────────────────────┤
│          │                  │          │    │                     │
├──────────┼──────────────────┼──────────┼────┼─────────────────────┤
│          │                  │          │    │                     │
└──────────┴──────────────────┴──────────┴────┴─────────────────────┘





┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━┳━━━━━┳━━━━━┳━━━━━┳━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃       Operations              ┃  X  ┃  N  ┃  Z  ┃  V  ┃  C  ┃                                     Operation                                            ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╋━━━━━╋━━━━━╋━━━━━╋━━━━━╋━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
├───────────────────────────────┼─────┼─────┼─────┼─────┼─────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                               │     │     │     │     │     │                                                                                          │
└───────────────────────────────┴─────┴─────┴─────┴─────┴─────┴──────────────────────────────────────────────────────────────────────────────────────────┘









├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
├─────────────────┼─────────────────────┼─────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                     │                     │                                                                                          │
│                 │                     │                     │                                                                                          │
└─────────────────┴─────────────────────┴─────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘

# Directives

┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃   Directive     ┃         Syntax            ┃                                     Operation                                            ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
│ ABCD            │  <label> EQU <number>     │ Equate a value to a label. The EQU directive associates a given value specified by a     │
│                 │                           │ number or numeric equation with a required label. Using this label in subsequent code    │
│                 │                           │ will result in a direct subst- itution of the associated value. Note that a label must   │
│                 │                           │ be defined within a file before it is used. Once defined with an EQU statement, a label  │
│                 │                           │ cannot be redefined.                                                                     │
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ RS              │ symbol name RS.size count │ This directive, together with the following two associated directives, operate on        │
│                 │                           │ or with the Assembler variable, __RS, which contains the current offset.                 │
│                 │ where .size is            │                                                                                          │
│                 │        .b byte            │ When the Automatic Even assembler option (/AE) is in force, RS directives for word       │
│                 │        .w word            │ and long word ensure that the __RS variable is aligned to the next word boundary.        │
│                 │        .l long word       │                                                                                          │
│                 │ (if .size is not          │ Examples                                                                                 │
│                 │  specified, .w is         │               RSRESET                                                                    │
│                 │ assumed)                  │     Icon_no:  RS.B 1                                                                     │
│                 │                           │     Dropcode: RS.W 1                                                                     │
│                 │                           │     Actcode:  RS.W 1                                                                     │
│                 │                           │     Actname:  RS.B 10                                                                    │
│                 │                           │     Objpos:   RS.L 1                                                                     │
│                 │                           │     Artlen:   RS.B 0                                                                     │
│                 │                           │                                                                                          │
│                 │                           │ After each of the first five RS equates, the __RS pointer is advanced; the values for    │
│                 │                           │ each equate are as follows:                                                              │
│                 │                           │                                                                                          │  
│                 │                           │  Icon_no  0 (set to zero by RSRESET)                                                     │ 
│                 │                           │  Dropcode 1                                                                              │
│                 │                           │  Actcode  4 (Automatic Even set, advances the pointer to even boundary)                  │
│                 │                           │  Actname  6                                                                              │
│                 │                           │  Objpos   16                                                                             │
│                 │                           │  Artlen   20                                                                             │
│                 │                           │                                                                                          │
│                 │                           │                __rs = 0                                                                  │
│                 │                           │                         + 1B                                                             │
│                 │                           │                __rs = 1                                                                  │
│                 │                           │                         + 2B                                                             │
│                 │                           │                __rs = 3 + 1B (to keep on even boundary)                                  │
│                 │                           │                __rs = 4                                                                  │
│                 │                           │                         + 2B                                                             │
│                 │                           │                __rs = 6                                                                  │
│                 │                           │                         + 10B                                                            │
│                 │                           │                __rs = 16                                                                 │
│                 │                           │                         + 1L                                                             │
│                 │                           │                __rs = 20                                                                 │
│                 │                           │                                                                                          │
│                 │                           │                                                                                          │
│                 │                           │  The last rs.b does not advance the __RS pointer, since a count of zero is equivalent    │
│                 │                           │  to an EQUATE to the __RS variable.                                                      │
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ RSRESET         │ Syntax RSRESET [value]    │ Description Sets the __RS variable to zero.                                              │
│                 │                           │                                                                                          │
│                 │                           │ * Using this directive is the normal way to initialise the __RS counter at the start of  │
│                 │                           │   a new data structure.                                                                  │
│                 │                           │ * The optional parameter is provided for compatibility with other assemblers;            │
│                 │                           │   if present, RSRESET behaves like the RESET directive.                                  │
│                 │                           │                                                                                          │
│                 │                           │ Examples See the RS directive                                                            │
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ RSSET           │ RSSET value               │ Assigns the specified value to __RS variable                                             │
│                 │                           │ This directive is normally used when the offsets are to start at a value other than zero.│
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│ DC              │ [<label>] DC.B <string>   │ Operation:                                                                               │ 
│                 │ [<label>] DC.B <data list>│     Define constant. The DC directive places the specified data or string within the     │
│                 │ [<label>] DC.W <data list>│     instruction stream.  The relative address of the first piece of data defined by a DC │
│                 │ [<label>] DC.L <data list>│     statement can be referenced by an optional label.  If a length extension             │
│                 │                           │     (.B, .W, or .L) is not specified, the byte value is used for strings and the word    │
│                 │                           │     value for numeric data. All data will be rounded to word size.  This means that an   │
│                 │                           │     extra byte will be added to the end of a constant DC.B declaration if the string or  │
│                 │                           │     numeric list have an odd number items.                                               │
│                 │                           │                                                                                          │
│                 │                           │ Strings:                                                                                 │ 
│                 │                           │    A string is represented by a sequence of characters enclosed in quotes ("). Several   │
│                 │                           │    escape sequences, beginning with a backslash (\\) may also be specified within a      │
│                 │                           │    string.  \\\\ backslash \\r return character \\n newline character \\p pascal string  │
│                 │                           │    (leading length byte) \\c c-string (following null byte) All strings will have no     │
│                 │                           │    following or leading bytes unless specified.                                          │
│                 │                           │                                                                                          │
│                 │                           │ Data List:                                                                               │
│                 │                           │    A data list consists of a sequence of numbers or numeric equations separated by       │
│                 │                           │    commas.  .300302                                                                      │
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                           │                                                                                          │
│                 │                           │                                                                                          │
├─────────────────┼───────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────┤
│                 │                           │                                                                                          │
│                 │                           │                                                                                          │
└─────────────────┴───────────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────┘

# Special Parameters
    There are a number of special parameter formats available in macros, as follows:

## Converting Integers to Text
    The parameters \# and \$ replace the decimal (#) or hex ($) value of the symbol following them,
    with their character representation. (& allows multi line strings)
    Commonly, this technique is used to access Run Date and Time:

    Example 
        org $1006
        RunTime dc.b "\#_hours:\#_minutes:&
        \#_seconds"

        this expands to the form hh:mm:ss, as follows
        RunTime dc.b "21:08:49"

## Generating Unique Labels
    The parameter \@ can be used as the last characters of a label name in a macro.
    When the macro is invoked, this will be expanded to an underscore followed by a decimal number; 
    this number is increased on each subsequent invocation to give a unique label.

    Example 
        Slots MACRO
            MOVEQ #0,d0
            MOVE.1 r1,\1
            BEQ.S dun@
        next\@ ADDQ.w #1, d0

            bGT.S
        dun\@ MOVE.w d0,2
            ENDM
            ...
            Slots freeob1,numslot1w

    Each time the Slots macro is used, new labels in the form next_001 and dun_001 will
    be generated.

## Entire Parameter
    If the special parameter \_ (backslash underscore) is encountered in a macro, it is expanded to the complete
    argument specified on the macro invocation statement.

    Examples 
    All MACRO
        DC.B \_
        ENDM
        ...
        All 1,2,3,4

    Will generate
    DB 1,2,3,4

# Syntax and Scope
    Syntax
        * Local Labels are preceded by a local label signifier. By default, this is an @ sign;
          however, any other character may declared by using the l option in an OPT
          directive or on the Assembler command line - see Assembler Options chapter 3.
        * Local label names follow the general label rules, as specified in chapter 4.
        * Local labels are not de-scoped by the expansion of a macro.
    Scope 
        The region of code within which a Local Label is effective is called its Scope. Outside this area, the label name can be re-used.
        There are three methods of defining the scope of a Local Label:
        * The scope of a local label is implicitly defined between two non-local labels.
          Setting a variable, defining an equate or RS value does not de-scope current local
          labels, unless the d option has been used in an OPT directive or on the Assembler command line.
        * The scope of a Local Label can also, and more normally, be defined by the directives MODULE and MODEND.
        * To define labels (or any other symbol type) for local use in a macro, the LOCAL directive can be used.

        Examples 
            plot2 move.b comp\w,d3
                ...
                 cmp.w #-84,d3
                 bge.s @chk1
                 add.w #168,d3
                 bra.s @ret
            @chk1 cmp.w #83,d3
                 ...
                 jsr lcolour
                 move.w d3,d0
            SetX set x+1
                @ret rts
            plot3 movem.w d6-d7,-(sp)
                ...
                @ret rts

        The code above shows a typical use for Local Labels, as "place markers" within a self-contained sub-routine. 
        The scope is defined by the non-local labels, Plot2 and Plot3; 
        the SET statement does not de-scope the routine. The labels @chk1 and @ret are re-usable.

        plot2 move.b comp\w,d3
            moveq chrbit-1,d2
             cmp.w #-84,d3
             bge.s @chk1
             add.w #168,d3
             bra.s setplot
        @chk1 cmp.w #83,d3
            move.w d3,d0
        setplot set x+1
            ...
            dbra d2,@chk1

        In the example, the final branch will cause an error, since it is outside the scope of
        @chk1.


# Integer Constants
    Integer constants are normally evaluated as decimal, the default base, unless one of the following pertains:
    * The RADIX directive changes the base - see chapter 3.
    * $, as the first character of an integer, signifies a Hex number; % signifies a Binary number.
    * If a character is preceded by a backslash and up arrow (\^), the corresponding control character is substituted.
    * The AN Assembler option allows numbers to be defined as Intel and Zilog integers. That is, the number must start with a numeric character and end with one of:
        D for Decimal; H for Hexadecimal; B for Binary

# Special Constants
    The following pre-defined constants are available in the Assemblers.
        _year As a two digit number, e.g. 95
        _month 1 = January; 12 = December
        _day 1 = 1st day of month
        _weekday 0 = Sunday; 6 = Saturday
        _hours 00 - 23
        _minutes 00 - 59
        _seconds 00 - 59
        * Contains the current value of the Location Counter.
        @ Contains the actual PC value at which the current value will be stored - see below.
        narg Contains the number of parameters in the current macro argument.
        __rs Contains the current value of RS Counter.
        _filename A pre-defined string containing the name of the primary file undergoing assembly.

    Remarks Time and Date Constants:
        Time and Date constants are set to the start of assembly; they are not updated during the assembly process.
        Example 
            RunTime dc.b "\#_hours:\#_minutes:&
                \#_seconds"
        This expands to the form hh:mm:ss, as follows
        RunTime dc.b "21:08:49"
        Note This example uses the special macro parameter, \#.

# Location Counter constants:
    The current value of the program pointer can be used as a constant. 
    To substitute the value of the location counter at the current position, an asterisk (*) is used:
            section Bss,g_bss
        Firstbss equ *

    Since * gives the address of the start of the line,
        org $100
        dc.l *,*,*
        defines $100 three times.

    An @, when used on its own as a constant, substitutes the value of the location counter, 
    pointing to an address at which the current value will be stored.
        org $100
        dc.l @,@,@
        defines $100,$104,$108.



# MACRO, ENDM, MEXIT
    Description A macro consists of the source lines and parameter place markers between the MACRO directive and the ENDM.
    The label field is the symbolic name by which the macro is invoked; the operand allows the entry of a string of parameter data names.
    When the assembler encounters a directive consisting of the label and optional parameters, 
    the source lines are pulled into the main program and expanded by substituting the place markers with the invocation parameters.
    The expansion of the macro is stopped immediately if the assembler encounters a MEXIT directive.

    Syntax 
        Label MACRO [symbol,..symbol]
        ...
        MEXIT
        ...
        ENDM

    Remarks
        * Note that the invocation parameter string effectively starts at the character after the macro name, that is, the dot (.) character. Text strings, as well as .b, .w and .l are permissible parameters - see Parameters below.
        * Control structures within macros must be complete. Structures started in the macro must finish before the ENDM; similarly, a structure started externally must not be terminated within the macro. To imitate a simple control structure from another assembler, a short macro might be used - see MACROS below.
    Examples 
        remove macro
             dc.w -2,0,0
          endm

        Form macro
             if strcmp('\1','0')
                 dc.w 0
             else
                 dc.w \1-FormBase
             endif
         endm


## Macro Parameters 

### Parameters Macro 
    parameters obey the following rules:
* The parameters listed on the macro invocation line may appear at any point in the code declared between the MACRO and ENDM statements. Each parameter is introduced by a backslash (\); where this may be confused with text from an EQUS, a backslash may also follow the parameter.
* Up to thirty two different parameters are allowed, numbered \0 to \31. \0 is a special parameter which gives the contents of the size field of the macro directive when it was invoked, that is, the text after the point symbol (.) This includes not only .b, .h or .w, but also any text: 
    Example 
        zed macro \0
            endm
            ...
            zed.nop
    will generate a NOP instruction.

Instead of the \0 to \31 format, parameters can be given symbolic names, by their inclusion as operands to the MACRO directive. The preceding backslash (\) is not mandatory; however, if there is the possibility of confusion with the surrounding text, a backslash may be used before and after the symbol name to ensure the expression is expanded correctly:
    Example 
        Position macro A,B,C,Pos,Time
            dc.w \Time*(\A*\Pos+\B*\Pos+\C*\Pos)
            endm

Surrounding the operand of an invoked macro with greater than and less than signs (<...>), allows the use of comma and space characters. This does not apply to Assemblers which use angle brackets as address mode specifiers; in these instances, backward single quote is used.

    Example 
        Credits macro
            dc.w \1,\2
            dc.b \3
            dc.b 0
            even
            endm
        ...
        Credits 11,10,<Psy-Q, from Psygnosis>

• Continuation Lines - when invoking a macro, it is possible that the parameter list will become overlong. As with any directive statement, the line can be terminated by an ampersand (&) and continued on the next line to improve readability.
    Example 
        chstr macro
             rept narg
             dc.b k_\1
             shift
             endr
             dc.b 0
             even
             endm
            ...
            cheatstr chstr i,c,a,n,b,a,r,e,l,y,&
            s,t,a,n,d,i,t






# Glossary
CCR: Condition Code Register
cc: carry clear
BCD: Binary-Coded Decimal
SR: status register
l: 32 bits
w: 16 bits
b: 8 bits
ATC: Address translation caches
NAN: Not a Number
SNAN: Signaling NAN
FPC or FPCR: floating point control register
FPS or FPSR: floating point status register
ALU: arithmetic logic unit
UNFL: underflow
INEX2: inexact bit
OVFL: overflow
FPCC: Floating-point Condition Code
EQ: equal to
GT: greater than
LT: less than
UN: unordered



# References
* http://68k.hax.com/
* https://en.wikibooks.org/wiki/68000_Assembly
* http://info.sonicretro.org/Redhotsonic
* http://mrjester.hapisan.com/04_MC68/ 
* http://www.easy68k.com/paulrsm/doc/trick68k.htm
* https://antime.kapsi.fi/sega/files/SATMAN.pdf
